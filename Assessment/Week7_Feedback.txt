Starting weekly assessment for Rachel, Week7

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 87.42 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week6, Week1, Week7, Assessment, HPC, Week5, Week2, Week4, .git, Week3, Project, MiniProject

Found the following files in parent directory: README.txt, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~ 
*.tmp
*.aux 
*.dvi 
*.log 
*.nav 
*.out 
*.snm 
*.toc
*py[cod] 
*.class
_pycache_
*.pyc
*.bbl
*.blg
-
.ipynb_checkpoints
*.synctex.gz
**********************************************************************

Found README in parent directory, named: README.txt

Printing contents of README.txt:
**********************************************************************
My CMEE Coursework Repository
Created by Rachel Bates 02/10/18

A repository containing all code and example data from a 9 week intro to biological computing masters. 

Week 1:		Introduction to Unix, LaTeX and Shell Scripting
Week 2:		Introduction to Python3
Week 3:		Introduction to R
Week 4:		Stats in R
Week 5:		GIS in QGIS
Week 6:		Genomics and Bioinformatics
Week 7:		Python 2
Week 8:		MiniProject: Model fitting miniproject
Week 9: 	HPC: High Performance Computing Week
Assessment: 	Outputs from an auto assessing Python script
Project:	Initial work for the MRes research project

Languages used:
- Bash
- LaTeX
- R
- Python 3

Specific versions used are specified within individual sub-directories' README documents. The README also contains details of any packages needed to run those scripts (none needed if none specified).

Directory structures for each week will be as follows (may change slightly depending on the content of the week):
Code:	 	All code
Data:		All files to be used as inputs for scripts
Output:		Where any files generated by scripts will be placed
Sandbox: 	Misc files and outputs used while learning and experimenting
**********************************************************************

======================================================================
Looking for the weekly directories...

Found 7 weekly directories: Week1, Week2, Week3, Week4, Week5, Week6, Week7

The Week7 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK7...

Found the following directories: Code, Data, Output, Sandbox

Found the following files: README.txt

Checking for readme file in weekly directory...

Found README in parent directory, named: README.txt

Printing contents of README.txt:
**********************************************************************
Week seven of CMEE Course Work
AUTHOR: Rachel Bates
DATE CREATED: 12/11/18

This directory contains Python scripts used to broaden python skills, namely in modelling systems, constructing networks, profiling, subroutines and regular expressions.

Python Version used: 3.5.2

Required Python packages:
	- scipy
	- networkx
	- matplotlib
	- re
	- sys
	- subprocess
	
R Version used: 3.2.3

Required R packages:
	-igraph

Sub-Directories:

Code:	 	All code
Data:		All files to be used as inputs for scripts
Output:		Where any files generated by scripts will be placed
Sandbox: 	Misc files and outputs used while learning and experimenting

Scripts:

blackbirds.py - Uses regular expressions to search a text file and extracts the kingdom, phylum and species data 

DrawFW.py - Generates an food web with random body masses and associations then plots a network map using networkx

fmr.R - Plots log(field metabolic rate) against log(body mass) for the Nagy et al 1999 dataset to a file fmr.pdf. Used to demonstrate uses of the Python subprocess module

LV1.py - Constructs a Lotka-Volterra Model given default inputs, and produces graphs of both species over time and both species in relation to each other

LV2.py - Constructs a Lotka-Volterra Model given user inputs, and produces graphs of both species over time and both species in relation to each other

LV3.py - Constructs a Lotka-Volterra Model given user inputs, and produces graphs of both species over (discrete) time and both species in relation to each other.

LV4.py - Constructs a Lotka-Volterra Model given user inputs, and produces graphs of both species over (discrete) time and both species in relation to each other with random fluctuations in growth rate

MyFirstJupyterNb.ipynb - Basic Jupyter notebook to demonstate its functionality

Nets.R - Builds a network - used as a template to recreate in Python

Nets.py - Builds a network of links between institutions. Translated from an R script

profileme.py - An example script to show profiling optimisations (pre-optimisation)

profileme2.py - An example script to show profiling optimisations (optimised)

regexs.py - Uses a series of example regex expressions to teach regular expressions

run_fmr_R.py - Uses subprocess to run fmr.R via python and export the outputs to the Output subdirectory

run_LV.py - Runs scripts detailing various versions of Lotka-Volterra models with required user inputs

TestR.py - Example use of subprocess to run an R script and capture the output 

TestR.R - A Test file for using to show example use of subprocess in Python

timeitme.py - Uses the timeit command to compare optimised functions with non-optimised functions, compares to using time

using_os.py - Uses subprocess and regular expressions to find files/directories named in certain ways

**********************************************************************

Results directory missing!

Creating Results directory...

Found 19 code files: TestR.py, regexs.py, LV3.py, profileme2.py, timeitme.py, blackbirds.py, Nets.py, TestR.R, profileme.py, LV4.py, fmr.R, MyFirstJupyterNb.ipynb, using_os.py, LV1.py, DrawFW.py, Nets.R, run_fmr_R.py, run_LV.py, LV2.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file TestR.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Example use of subprocess to run an R script and capture the output """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import subprocess

## CONSTANTS ##

# None

## FUNCTIONS ##

# None

################

#Runs R through bash! Sends any regular output to one file and errors to another
subprocess.Popen("/usr/lib/R/bin/Rscript --verbose TestR.R > \
../Output/TestR.Rout 2> ../Output/TestR_errFile.Rout",\
 shell=True).wait() #Wait makes sure you run all of the processes before exiting

**********************************************************************

Testing TestR.py...

TestR.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.19085s

======================================================================
Inspecting script file regexs.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Uses a series of example regex expressions to teach regular expressions """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import re

## CONSTANTS ##

my_string = "a given string"
MyStr = 'an example'

## FUNCTIONS ##

#None

################

match = re.search(r'\s', my_string) # Searches my_string for spaces
print(match) # shows a match has been found

match = re.search(r'\d', my_string)
print(match)


match = re.search(r'\w*\s', MyStr) #Searches my_string for any word followed by a space

#Simple statement to avoid error messages and give meaningful outputs
if match:                      
    print('found a match:', match.group()) 
else:
    print('did not find a match')    

#Finds "2"
match = re.search(r'2', 'it takes 2 to tango')
match.group()

#Finds any number
match = re.search(r'\d', 'it takes 2 to tango')
match.group()

#Finds any number and everything after that
match = re.search(r'\d.*', 'it takes 2 to tango')
match.group()

#Finds subsequent alphanumeric characters of length 1-3 between two spaces
match = re.search(r'\s\w{1,3}\s', 'once upon a time')
match.group()

#Matches the last word (alphanumeric string preceeded by a space)
match = re.search(r'\s\w*$', 'once upon a time')
match.group()

#Matches a word of any length, then spaces and numbers and any other character 
# (not required if not found), then ending in a number.
re.search(r'\w*\s\d.*\d', 'take 2 grams of H20').group()

# Starts with any number of alphanumeric characters, then any character any number
# of times, then ending with the final space.
re.search(r'^\w*.*\s', 'once upon a time').group()

# Starts with any number of alphanumeric characters, then one set of any characters
# before a space. (i.e: takes the first word)
re.search(r'^\w*.*?\s', 'once upon a time').group()

# Checks for all characters between first < and last >
re.search(r'<.+>', 'This is a <EM>first</EM> test').group()

# Checks for all characters between first < and first > by making the + "lazy"
# using ?
re.search(r'<.+?>', 'This is a <EM>first</EM> test').group()

# Any number of numbers, then a full stop, then any number of numbers
re.search(r'\d*\.?\d*','1432.75+60.22i').group()

#Searches for any sequences of A,T,C and/or G
re.search(r'[AGTC]+', 'A sequence ATTCGT').group()

# Finds a word of any size after any number of spaces, starting with a capital/s, 
# then a space, then another word of any size
re.search(r'\s+[A-Z]{1}\w+\s\w+', "The bird-shit frog's name is Theloderma asper").group()

**********************************************************************

Testing regexs.py...

regexs.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
<_sre.SRE_Match object; span=(1, 2), match=' '>
None
found a match: an 

**********************************************************************

Code ran without errors

Time consumed = 0.02849s

======================================================================
Inspecting script file LV3.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Constructs a Lotka-Volterra Model given user inputs, 
    and produces graphs of both species over (discrete) time and both species 
    in relation to each other """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import sys
import scipy as sc
import scipy.integrate as integrate
import matplotlib.pylab as p
import numpy as np

## CONSTANTS ##

if len(sys.argv) == 5:
     r = float(sys.argv[1])
     a = float(sys.argv[2])
     z = float(sys.argv[3])
     e = float(sys.argv[4])
else:
    print("ERROR: User did not supply 4 parameters for LV model (r a z e)")
    sys.exit()

t = list(range(0, 20))

K = 35
R0 = 10
C0 = 5 
RC0 = sc.array([[R0, C0]])

## FUNCTIONS ##

def R_t(pops, t=0):
    """ Defines the models for both species' growth in relation to one another 
        in discrete time """
    R = pops[0][0]
    C = pops[0][1]
    Pops = sc.array([[R,C]])
    for i in range(1,len(t)):
        R = R*(1+r*(1-(R/K))-a*C)
        C = C*(1-z+e*a*R)
        Pops = np.append(Pops, [[R,C]], axis=0)
    return Pops

##########################

# Uses odeint to integrate the continuous differential equations
pops = R_t(RC0, t)

f1 = p.figure() # Creates an empty figure
# Defines parameters and labels for the plot of both pops over time
p.plot(t, pops[:][:,0], 'g-', label='Resource density') # Plot
p.plot(t, pops[:][:,1]  , 'b-', label='Consumer density')
p.grid()
p.legend(loc='best')
p.xlabel('Time')
p.ylabel('Population density')
p.title('Consumer-Resource population dynamics. \n r=%.2f, a=%.2f, z=%.2f, e=%.2f K=%d' % (r, a, z, e, K))
#p.show()# To display the figure

f1.savefig('../Output/LV3_model.pdf') #Save figure to pfd


f2 = p.figure() #Creates an empty figure
# Defines parameters and labels for the circle plot (each pop against each other)
p.plot(pops[:][:,0], pops[:][:,1], 'r-')
p.grid()
p.xlabel('Resource density')
p.ylabel('Consumer density')
p.title('Consumer-Resource population dynamics. \n r=%.2f, a=%.2f, z=%.2f, e=%.2f K=%d' % (r, a, z, e, K))
#p.show()# To display the figure

f2.savefig('../Output/LV3_model_circ.pdf') #Save figre to pdf

**********************************************************************

Testing LV3.py...

LV3.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
ERROR: User did not supply 4 parameters for LV model (r a z e)

**********************************************************************

Code ran without errors

Time consumed = 0.70554s

======================================================================
Inspecting script file profileme2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" An example script to show profiling optimisations (optimised) """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

# None

## CONSTANTS ##

# None

## FUNCTIONS ##

def my_squares(iters):
    """ Creates a list of square numbers from 0 to iters (10,000,000) 
    using list comprehension """
    out = [i ** 2 for i in range(iters)]
    return out

def my_join(iters, string):
    """ Creates a string of the inputted string 
        separated by commas, iters number of times """
    out = ''
    for i in range(iters):
        out += ", " + string
    return out

def run_my_funcs(x,y):
    """ Prints the inputted x and y objects, runs my_squares and my_join """
    print(x,y)
    my_squares(x)
    my_join(x,y)
    return 0

################

run_my_funcs(10000000,"My string")**********************************************************************

Testing profileme2.py...

profileme2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
10000000 My string

**********************************************************************

Code ran without errors

Time consumed = 3.62647s

======================================================================
Inspecting script file timeitme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Uses the timeit command to compare optimised functions 
    with non-optimised functions, compares to using time """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import timeit
import time

from profileme import my_squares as my_squares_loops
from profileme2 import my_squares as my_squares_lc

from profileme import my_join as my_join_join
from profileme2 import my_join as my_join

## CONSTANTS ##

iters = 10000000
mystring = "mystring"

## FUNCTIONS ##


##############

# Compares the time for both squares functions using timeit

# Commented out to avoid errors when running
#%timeit my_squares_loops(iters)
#%timeit my_squares_lc(iters)

# Compares the time for both joins using timeit

# Commented out to avoid errors when running
#%timeit my_join_join(iters, mystring)
#%timeit my_join(iters, mystring)


# Times the non-optimised code

start = time.time()
my_squares_loops(iters)
print("my_squares_loops takes %f s to run." % (time.time() - start))

# Times the optimised code

start = time.time()
my_squares_lc(iters)
print("my_squares_lc takes %f s to run." % (time.time() - start))
**********************************************************************

Testing timeitme.py...

timeitme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 10.00518s

======================================================================
Inspecting script file blackbirds.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Uses regular expressions to search a text file and extracts the kingdom, 
    phylum and species data """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import re

## CONSTANTS ##

# Read the file (using a different, more python 3 way, just for fun!)
with open('../Data/blackbirds.txt', 'r') as f:
    text = f.read()

## FUNCTIONS ##

#None

################

# replace \t's and \n's with a spaces:
text = text.replace('\t',' ')
text = text.replace('\n',' ')
# You may want to make other changes to the text. 

# In particular, note that there are "strange characters" (these are accents and
# non-ascii symbols) because we don't care for them, first transform to ASCII:

text = text.encode('ascii', 'ignore') # first encode into ascii bytes
text = text.decode('ascii', 'ignore') # Now decode back to string

# Regular expression that finds each instance of Kingdom name, Phylum name, and Species name
match = re.findall(r"Kingdom\s+([A-Z]\w+)\s.*?Phylum\s+([A-Z]\w+)\s.*?Species\s+([A-Z]\w+\s\w+)\s", text)

#Defines a header row
header = "Kingdom Phylum Species"

# Prints the found taxanomic data with headers
print(header + "\n" + "\n".join([" ".join(x) for x in match]))


**********************************************************************

Testing blackbirds.py...

blackbirds.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Kingdom Phylum Species
Animalia Chordata Euphagus carolinus
Animalia Chordata Euphagus cyanocephalus
Animalia Chordata Turdus boulboul
Animalia Chordata Agelaius assimilis

**********************************************************************

Code ran without errors

Time consumed = 0.02906s

======================================================================
Inspecting script file Nets.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Builds a network of links between institutions. Translated from an R script. """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'


## IMPORTS ##

import networkx as nx
import scipy as sc 
import matplotlib.pyplot as p 
import pandas as pd

## CONSTANTS ##

# Reads in the files as pandas dfs
links = pd.read_csv("../Data/QMEE_Net_Mat_edges.csv", header=0)
nodes = pd.read_csv("../Data/QMEE_Net_Mat_nodes.csv", header=0)

################

p.close("all") #Close any open graphics

################

# Makes the column names the same as the row names
links.columns = list(range(0,6))

w_links = list() #initialise list

# Creates a list of tuples, of position and weight of link
for i in range(0,6):
    for j in range(0,6):
        if links[i][j]>0:
            w_links.append((i,j,links[i][j]))

# Creates a list of colours for plot
color_map=["blue", "blue", "green", "green", "green", "red"]

# Create the network plot
pos = nx.random_layout(nodes.index.values)
G = nx.Graph()
G.add_nodes_from(nodes.index.values)
G.add_weighted_edges_from(w_links, arrows=True)


# Initialise figure
plot = p.figure()

# Draw the plot
nx.draw_networkx(G, pos, node_color = color_map, node_size=5000, with_labels=False)
nx.draw_networkx_labels(G, pos, nodes["id"])

plot.savefig('../Output/pyNets.svg') #Save the output**********************************************************************

Testing Nets.py...

Nets.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
/usr/lib/python3/dist-packages/networkx/drawing/nx_pylab.py:522: MatplotlibDeprecationWarning: The is_string_like function was deprecated in version 2.1.
  if not cb.is_string_like(edge_color) \
/usr/lib/python3/dist-packages/networkx/drawing/nx_pylab.py:543: MatplotlibDeprecationWarning: The is_string_like function was deprecated in version 2.1.
  if cb.is_string_like(edge_color) or len(edge_color) == 1:
/usr/lib/python3/dist-packages/networkx/drawing/nx_pylab.py:724: MatplotlibDeprecationWarning: The is_string_like function was deprecated in version 2.1.
  if not cb.is_string_like(label):

======================================================================
Inspecting script file TestR.R...

File contents are:
**********************************************************************
## A Test file for using to show example use of subprocess in Python

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

## Packages ##

#None

###############


print("Hello, this is R!")**********************************************************************

Testing TestR.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Hello, this is R!"

**********************************************************************

Code ran without errors

Time consumed = 0.08374s

======================================================================
Inspecting script file profileme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" An example script to show profiling optimisations (pre-optimisation) """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

# None

## CONSTANTS ##

# None

## FUNCTIONS ##

def my_squares(iters):
    """ Creates a list of square numbers from 0 to iters (10,000,000) using loops """
    out = []
    #range is an iterator rather than making a vector with all values 0-10
    for i in range(iters):
        out.append(i ** 2)
    return out

def my_join(iters, string):
    """ Creates a string of the inputted string 
        separated by commas, iters number of times """
    out = ''
    for i in range(iters):
        out += string.join(", ") # out = out + string.join simplified
    return out

def run_my_funcs(x,y):
    """ Prints the inputted x and y objects, runs my_squares and my_join """
    print(x,y)
    my_squares(x)
    my_join(x,y)
    return 0

################

run_my_funcs(10000000,"My string")**********************************************************************

Testing profileme.py...

profileme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
10000000 My string

**********************************************************************

Code ran without errors

Time consumed = 6.62252s

======================================================================
Inspecting script file LV4.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Constructs a Lotka-Volterra Model given user inputs, 
    and produces graphs of both species over (discrete) time and both species 
    in relation to each other with random fluctuations in growth rate """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import sys
import scipy as sc
import scipy.integrate as integrate
import matplotlib.pylab as p
import numpy as np

## CONSTANTS ##

if len(sys.argv) == 5:
     r = float(sys.argv[1])
     a = float(sys.argv[2])
     z = float(sys.argv[3])
     e = float(sys.argv[4])
else:
    print("ERROR: User did not supply 4 parameters for LV model (r a z e)")
    sys.exit()

t = list(range(0, 20))

K = 35
R0 = 10
C0 = 5 
RC0 = sc.array([[R0, C0]])

## FUNCTIONS ##

def R_t(pops, t=0):
    """ Defines the models for both species' growth in relation to one another 
        in discrete time """
    R = pops[0][0]
    C = pops[0][1]
    Pops = sc.array([[R,C]])
    for i in range(1,len(t)):
        epsilon=np.random.normal()
        R = R*(1+(r*epsilon)*(1-(R/K))-a*C)
        C = C*(1-z+e*a*R)
        Pops = np.append(Pops, [[R,C]], axis=0)
    return Pops

##########################

# Uses odeint to integrate the continuous differential equations
pops = R_t(RC0, t)

f1 = p.figure() # Creates an empty figure
# Defines parameters and labels for the plot of both pops over time
p.plot(t, pops[:][:,0], 'g-', label='Resource density') # Plot
p.plot(t, pops[:][:,1]  , 'b-', label='Consumer density')
p.grid()
p.legend(loc='best')
p.xlabel('Time')
p.ylabel('Population density')
p.title('Consumer-Resource population dynamics. \n r=%.2f, a=%.2f, z=%.2f, e=%.2f K=%d' % (r, a, z, e, K))
#p.show()# To display the figure

f1.savefig('../Output/LV4_model.pdf') #Save figure to pfd


f2 = p.figure() #Creates an empty figure
# Defines parameters and labels for the circle plot (each pop against each other)
p.plot(pops[:][:,0], pops[:][:,1], 'r-')
p.grid()
p.xlabel('Resource density')
p.ylabel('Consumer density')
p.title('Consumer-Resource population dynamics. \n r=%.2f, a=%.2f, z=%.2f, e=%.2f K=%d' % (r, a, z, e, K))
#p.show()# To display the figure

f2.savefig('../Output/LV4_model_circ.pdf') #Save figre to pdf

**********************************************************************

Testing LV4.py...

LV4.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
ERROR: User did not supply 4 parameters for LV model (r a z e)

**********************************************************************

Code ran without errors

Time consumed = 0.37970s

======================================================================
Inspecting script file fmr.R...

File contents are:
**********************************************************************
# Plots log(field metabolic rate) against log(body mass) for the Nagy et al 
# 1999 dataset to a file fmr.pdf.
# Used to demonstrate uses of the Python subprocess module

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

## Packages ##

#None

## Load Data ##

nagy <- read.csv('../Data/NagyEtAl1999.csv', stringsAsFactors = FALSE)

###############
cat("Reading CSV\n")

cat("Creating graph\n")
pdf('../Output/fmr_plot.pdf', 11, 8.5)
col <- c(Aves='purple3', Mammalia='red3', Reptilia='green3')
plot(log10(nagy$M.g), log10(nagy$FMR.kJ.day.1), pch=19, col=col[nagy$Class], 
     xlab=~log[10](M), ylab=~log[10](FMR))
for(class in unique(nagy$Class)){
    model <- lm(log10(FMR.kJ.day.1) ~ log10(M.g), data=nagy[nagy$Class==class,])
    abline(model, col=col[class])
}
dev.off()

cat("Finished in R!\n")
**********************************************************************

Testing fmr.R...

Output (only first 500 characters): 

**********************************************************************
Reading CSV
Creating graph
null device 
          1 
Finished in R!

**********************************************************************

Code ran without errors

Time consumed = 0.15575s

======================================================================
Inspecting script file MyFirstJupyterNb.ipynb...

File contents are:
**********************************************************************
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1] \"this is python!\"\n"
     ]
    }
   ],
   "source": [
    "a = \"this is python!\"; print(a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "this is R!"
     ]
    }
   ],
   "source": [
    "a <- \"this is R!\"; cat(a)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#isn't working?\n",
    "import matplotlib.pyplot as p\n",
    "import scipy as sc\n",
    "\n",
    "x = sc.arange(0, 5, 0.1)\n",
    "y = sc.sin(x)\n",
    "p.plot(x, y)\n",
    "p.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {},
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAYwAAAEsCAMAAADn+3SWAAAC+lBMVEUAAAABAQECAgIDAwME\nBAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUW\nFhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJyco\nKCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6\nOjo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tM\nTExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1e\nXl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29w\ncHBxcXFycnJzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGC\ngoKDg4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OU\nlJSVlZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2fn5+goKChoaGioqKjo6OkpKSlpaWmpqan\np6eoqKiqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4uLi5ubm6\nurq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnKysrLy8vM\nzMzNzc3Ozs7Pz8/Q0NDR0dHS0tLT09PU1NTV1dXW1tbX19fY2NjZ2dna2trb29vc3Nzd3d3e\n3t7f39/g4ODh4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u7u7v7+/w\n8PDx8fHy8vLz8/P09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7///8i96bfAAAA\nCXBIWXMAABJ0AAASdAHeZh94AAAVXUlEQVR4nO2de3gURbbAz0xCIAgYgq7gwhVUWBGVlSyu\n6/WFd68PZIwKgkIQBHRVROUuiigPEaOy64oIrLjqKuKK4gNEFkVliShoBCG8H5sESMijVgJ5\n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\nQmCC",
      "text/plain": [
       "plot without title"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "require(ggplot2)\n",
    "library(repr)# to resize plot within jupyter - this package is part of IRKernel\n",
    "options(repr.plot.width=3.3,repr.plot.height=2.5)\n",
    "\n",
    "x <- seq(0, 5, 0.1); y <- sin(x)\n",
    "qplot(x, y, geom = \"line\") # large figure"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.5.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
**********************************************************************

Testing MyFirstJupyterNb.ipynb...

======================================================================
Inspecting script file using_os.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Uses subprocess and regular expressions to find files/directories 
    named in certain ways """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import subprocess
import re

## CONSTANTS ##

home = subprocess.os.path.expanduser("~")

## FUNCTIONS ##

# None

#################################

# Use the subprocess.os module to get a list of files and  directories 
# in your ubuntu home directory 

p = subprocess.Popen(["ls", "-l", "~"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
stdout, stderr = p.communicate()
# Hint: look in subprocess.os and/or subprocess.os.path and/or 
# subprocess.os.walk for helpful functions

#~Get a list of files and 
#~directories in your home/ that start with an uppercase 'C'

# Type your code here:

# Create a list to store the results.
FileC = []

# Use a for loop to walk through the home directory.
for (directory, subdir, files) in subprocess.os.walk(home):
    # Use lc to check for subdirs starting with C
    FileC += [name for name in subdir if re.match(r"^C+", name)!=None]

for (directory, subdir, files) in subprocess.os.walk(home):
    # Use lc to check for files starting with C
    FileC += [name for name in files if re.match(r"^C+", name)!=None]

#################################
# Get files and directories in your home/ that start with either an 
# upper or lower case 'C'

# Type your code here:

FileCc = []

for (directory, subdir, files) in subprocess.os.walk(home):
    FileCc += [name for name in subdir if re.match(r"^[Cc]+", name)!=None]

for (directory, subdir, files) in subprocess.os.walk(home):
    FileCc += [name for name in files if re.match(r"^[Cc]+", name)!=None]

#################################
# Get only directories in your home/ that start with either an upper or 
#~lower case 'C' 

# Type your code here:

DirCc = []

for (directory, subdir, files) in subprocess.os.walk(home):
    DirCc += [name for name in subdir if re.match(r"^[Cc]+", name)!=None]**********************************************************************

Testing using_os.py...

using_os.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 10.00654s

======================================================================
Inspecting script file LV1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Constructs a Lotka-Volterra Model given default inputs, 
    and produces graphs of both species over time and both species 
    in relation to each other """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import scipy as sc
import scipy.integrate as integrate
import matplotlib.pylab as p

## CONSTANTS ##

r = 1.
a = 0.1 
z = 1.5
e = 0.75

t = sc.linspace(0, 15,  1000)

R0 = 10
C0 = 5 
RC0 = sc.array([R0, C0]) 

## FUNCTIONS ##

def dCR_dt(pops, t=0):
    """ Defines the models for both species' growth in relation to one another 
        in continuous time """
    R = pops[0]
    C = pops[1]
    dRdt = r * R - a * R * C 
    dCdt = -z * C + e * a * R * C
    #Returns N for each species at each time step
    return sc.array([dRdt, dCdt])


################

# Uses odeint to integrate the continuous differential equations
pops, infodict = integrate.odeint(dCR_dt, RC0, t, full_output=True)

# Creates an empty figure
f1 = p.figure()
# Defines parameters and labels for the plot of both pops over time
p.plot(t, pops[:,0], 'g-', label='Resource density') 
p.plot(t, pops[:,1]  , 'b-', label='Consumer density')
p.grid()
p.legend(loc='best')
p.xlabel('Time')
p.ylabel('Population density')
p.title('Consumer-Resource population dynamics')
#p.show()# To display the figure

f1.savefig('../Output/LV_model.pdf') #Save figure as pdf

# Creates an empty figure
f2 = p.figure()
# Defines parameters and labels for the circle plot (each pop against each other)
p.plot(pops[:,0], pops[:,1], 'r-')
p.grid()
p.xlabel('Resource density')
p.ylabel('Consumer density')
p.title('Consumer-Resource population dynamics')
#p.show()# To display the figure

f2.savefig('../Output/LV_model_circ.pdf') # save figure as pdf**********************************************************************

Testing LV1.py...

LV1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.80311s

======================================================================
Inspecting script file DrawFW.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Generates an food web with random body masses and associations
    then plots a network map using networkx """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import networkx as nx
import scipy as sc 
import matplotlib.pyplot as p 

## CONSTANTS ##

MaxN = 30
C = 0.75

## FUNCTIONS ##

def GenRdmAdjList(N=2, C=0.5):
    """ Creates a list of connected species (N) using a given 
        probability of connection (C) """
    Ids = range(N) # makes a new list of 0-N inclusive
    AList = []
    for i in Ids:
        if sc.random.uniform(0,1,1) < C:
            #sc works with numpy arrays so need to coerce to list
            Lnk = sc.random.choice(Ids,2).tolist() 
            if Lnk[0] !=Lnk[1]:
                AList.append(Lnk)
    return AList

################

# Runs the connectedness function and places the output into an array
AdjL = sc.array(GenRdmAdjList(MaxN, C))

# Assigns each species an ID
Sps = sc.unique(AdjL)

# Creates an array of numbers between -10 and 10 n=MaxN
Sizes = sc.random.uniform(-10, 10, MaxN)

# Creates a histogram of the sizes
#p.hist(Sizes)

# Ensures all matplotlib devices are closed 
p.close("all")

# Indicates the node layout on the graph
pos = nx.circular_layout(Sps)

#Generates a network graph
G = nx.Graph()

# Places the species as nodes
G.add_nodes_from(Sps)
# Add connecting lines
G.add_edges_from(tuple(AdjL))

#Make the sizes match the randomly generated sizes (scaled up to be viewable)
NodSizes = 1000 * (Sizes-min(Sizes))/(max(Sizes)-min(Sizes))

plot = p.figure()
# Draw the network
nx.draw_networkx(G, pos, node_size=NodSizes)

#Save as pdf
plot.savefig('../Output/RndNetwork.pdf')**********************************************************************

Testing DrawFW.py...

DrawFW.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
/usr/lib/python3/dist-packages/networkx/drawing/nx_pylab.py:522: MatplotlibDeprecationWarning: The is_string_like function was deprecated in version 2.1.
  if not cb.is_string_like(edge_color) \
/usr/lib/python3/dist-packages/networkx/drawing/nx_pylab.py:543: MatplotlibDeprecationWarning: The is_string_like function was deprecated in version 2.1.
  if cb.is_string_like(edge_color) or len(edge_color) == 1:
/usr/lib/python3/dist-packages/networkx/drawing/nx_pylab.py:724: MatplotlibDeprecationWarning: The is_string_like function was deprecated in version 2.1.
  if not cb.is_string_like(label):

======================================================================
Inspecting script file Nets.R...

File contents are:
**********************************************************************
## Builds a network - used as a template to recreate in Python

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

## Packages ##

library(igraph)

## Load Data ##

links <- read.csv("../Data/QMEE_Net_Mat_edges.csv", header=T, as.is=T)
nodes <- read.csv("../Data/QMEE_Net_Mat_nodes.csv", header=T, row.names = 1)

###############

#Create graph object
net <- graph.adjacency(as.matrix(links), mode = "directed", weighted=TRUE, diag=F)
        
# Generate colors based on partner type:
colrs <- c("green", "red", "blue")
V(net)$color <- colrs[nodes$Type]

V(net)$size <- 50

# Set edge width based on weight (PhD Students):
E(net)$width <- E(net)$weight

#change arrow size and edge color:
E(net)$arrow.size <- 1
E(net)$edge.color <- "gray80"

E(net)$width <- 1+E(net)$weight/10

graphics.off()

svg("../Output/QMEENet.svg",width=7,height=7)

plot(net, edge.curved=0, vertex.label.color="black") 

legend(x=-1.5, y=-0.1, c("Hosting Partner", "Non-hosting Partner","University"), pch=21,
       col="#777777", pt.bg=colrs, pt.cex=2, cex=.8, bty="n", ncol=1)

dev.off()
**********************************************************************

Testing Nets.R...

Output (only first 500 characters): 

**********************************************************************
null device 
          1 

**********************************************************************

Encountered error:
Loading required package: methods

Attaching package: ‘igraph’

The following objects are masked from ‘package:stats’:

    decompose, spectrum

The following object is masked from ‘package:base’:

    union


======================================================================
Inspecting script file run_fmr_R.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Uses subprocess to run fmr.R via python and displays the R output.
    Also exports the outputs to the Output subdirectory """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import subprocess

## CONSTANTS ##

# None

## FUNCTIONS ##

# None

################

try:
    # Runs the subprocess, giving the output
    subprocess.check_call("/usr/lib/R/bin/Rscript --verbose fmr.R \
    ../Output/fmr.Rout 2> ../Output/fmr_errFile.Rout",\
    shell=True)
    print ("\nExecution Sucessful") #Will only print if no errors are found

except subprocess.CalledProcessError: #If 1 or more error is found
    print ("ERROR: Subprocess not carried out sucessfully")

**********************************************************************

Testing run_fmr_R.py...

run_fmr_R.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Reading CSV
Creating graph
null device 
          1 
Finished in R!

Execution Sucessful

**********************************************************************

Code ran without errors

Time consumed = 0.16207s

======================================================================
Inspecting script file run_LV.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Runs scripts detailing various versions of Lotka-Volterra 
    models with required user inputs """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

# None

## CONSTANTS ##

# None

## FUNCTIONS ##

# None

################

# Runs LV1 with profiling
run -p LV1.py
# Runs LV2 with given inputs for parameters, with profiling
run -p LV2.py 1 0.1 1.5 0.75
# Runs LV3 with given inputs for parameters, with profiling
run -p LV3.py 1 0.1 1.5 0.75
# Runs LV3 with given inputs for parameters, with profiling
run -p LV4.py 1 0.1 1.5 0.75**********************************************************************

Testing run_LV.py...

run_LV.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
  File "run_LV.py", line 24
    run -p LV1.py
             ^
SyntaxError: invalid syntax

======================================================================
Inspecting script file LV2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Constructs a Lotka-Volterra Model given user inputs, 
    and produces graphs of both species over time and both species 
    in relation to each other """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import sys
import scipy as sc
import scipy.integrate as integrate
import matplotlib.pylab as p

## CONSTANTS ##

if len(sys.argv) == 5:
     r = float(sys.argv[1])
     a = float(sys.argv[2])
     z = float(sys.argv[3])
     e = float(sys.argv[4])
else:
    print("ERROR: User did not supply 4 parameters for LV model (r a z e)")
    sys.exit()

t = sc.linspace(0, 15,  1000)

K = 35
R0 = 10
C0 = 5 
RC0 = sc.array([R0, C0]) 

## FUNCTIONS ##

def dCR_dt(pops, t=0):
    """ Defines the models for both species' growth in relation to one another 
        in continuous time """
    R = pops[0]
    C = pops[1]
    dRdt = r * R * (1-(R / K)) - a * R * C 
    dCdt = -z * C + e * a * R * C
    return sc.array([dRdt, dCdt])

##########################

# Uses odeint to integrate the continuous differential equations
pops, infodict = integrate.odeint(dCR_dt, RC0, t, full_output=True)

f1 = p.figure() # Creates an empty figure
# Defines parameters and labels for the plot of both pops over time
p.plot(t, pops[:,0], 'g-', label='Resource density') # Plot
p.plot(t, pops[:,1]  , 'b-', label='Consumer density')
p.grid()
p.legend(loc='best')
p.xlabel('Time')
p.ylabel('Population density')
p.title('Consumer-Resource population dynamics. \n r=%.2f, a=%.2f, z=%.2f, e=%.2f K=%d' % (r, a, z, e, K))
#p.show()# To display the figure

f1.savefig('../Output/LV2_model.pdf') #Save figure to pfd


f2 = p.figure() #Creates an empty figure
# Defines parameters and labels for the circle plot (each pop against each other)
p.plot(pops[:,0], pops[:,1], 'r-')
p.grid()
p.xlabel('Resource density')
p.ylabel('Consumer density')
p.title('Consumer-Resource population dynamics. \n r=%.2f, a=%.2f, z=%.2f, e=%.2f K=%d' % (r, a, z, e, K))
#p.show()# To display the figure

f2.savefig('../Output/LV2_model_circ.pdf') #Save figre to pdf

**********************************************************************

Testing LV2.py...

LV2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
ERROR: User did not supply 4 parameters for LV model (r a z e)

**********************************************************************

Code ran without errors

Time consumed = 0.37377s

======================================================================
======================================================================
Finished running scripts

Ran into 4 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 100

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!