Starting weekly assessment for Rachel, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 19.33 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week6, Week1, Week7, Assessment, HPC, Week5, Week2, Week4, .git, Week3, Project, MiniProject

Found the following files in parent directory: README.txt, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~ 
*.tmp
*.aux 
*.dvi 
*.log 
*.nav 
*.out 
*.snm 
*.toc
*py[cod] 
*.class
_pycache_
*.pyc
*.bbl
*.blg
-
.ipynb_checkpoints
*.synctex.gz
**********************************************************************

Found README in parent directory, named: README.txt

Printing contents of README.txt:
**********************************************************************
My CMEE Coursework Repository
Created by Rachel Bates 02/10/18

A repository containing all code and example data from a 9 week intro to biological computing masters. 

Week 1:		Introduction to Unix, LaTeX and Shell Scripting
Week 2:		Introduction to Python3
Week 3:		Introduction to R
Week 4:		Stats in R
Week 5:		GIS in QGIS
Week 6:		Genomics and Bioinformatics
Week 7:		Python 2
Week 8:		MiniProject: Model fitting miniproject
Week 9: 	HPC: High Performance Computing Week
Assessment: 	Outputs from an auto assessing Python script
Project:	Initial work for the MRes research project

Languages used:
- Bash
- LaTeX
- R
- Python 3

Specific versions used are specified within individual sub-directories' README documents. The README also contains details of any packages needed to run those scripts (none needed if none specified).

Directory structures for each week will be as follows (may change slightly depending on the content of the week):
Code:	 	All code
Data:		All files to be used as inputs for scripts
Output:		Where any files generated by scripts will be placed
Sandbox: 	Misc files and outputs used while learning and experimenting
**********************************************************************

======================================================================
Looking for the weekly directories...

Found 7 weekly directories: Week1, Week2, Week3, Week4, Week5, Week6, Week7

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: Code, Data, Output, Sandbox

Found the following files: README.txt

Checking for readme file in weekly directory...

Found README in parent directory, named: README.txt

Printing contents of README.txt:
**********************************************************************
Week two of CMEE Course Work
AUTHOR: Rachel Bates
DATE CREATED: 08/10/18

This directory contains python scripts used to learn the basics of the python 3 language, as well as example data used to run those scripts.

Python Version used: 3.5.2

Required Python packages:
	-pandas
	-csv
	-sys
	-pickle
	-ipdb
	-doctest 

Sub-Directories:

Code:	 	All code
Data:		All files to be used as inputs for scripts
Output:		Where any files generated by scripts will be placed
Sandbox: 	Misc files and outputs used while learning and experimenting


Scripts:

align_seqs.py - Compares the DNA base sequences contained within a specified csv file and finds the position at which they most closely match

align_seqs_better.py - Compares two DNA base sequences and finds the position at which they most closely match. Where there are multiple best matches, it records all of them. The best matches are outputted to a file in ../Output/ 

align_seqs_fasta.py - Compares two DNA base sequences from two input files and finds the position at which they most closely match

basic_csv.py - Demonstates the usage of the csv library to read, manipulate and write to csv files

basic_io.py - Several blocks of script demonsrating the ways to input and output data from files into python, or to files out of python

boilerplate.py - Placeholder script for correctly formatting modules in a pythonic fashion

cfexercises1.py - Exercises detailing the usage of control statements and control flow

cfexercises2.py - Additional exercises detailing the usage of control statements and control flow

control_flow.py - Some functions exemplifying the use of control statements

debugme.py - A script with inbuilt bugs to demonstrate debugging practices

dictionary.py - Creates a dictionary of species' latin names sorted by Order

lc1.py - Creates lists of one attribute for several bird species in one tuple

lc2.py - Creates lists of both months in 1910 where rainfall was less than 50mm and month, rainfall tuples where rainfall exceeded 100mm. This is done via both loops and list comprehensions

loops.py - Some functions exemplifying the use of loops statements

oaks.py - Finds just those species that are oaks from a list of species' latin names

oaks_debugme.py - Module that checks a list of latin names to see which are oaks, and exports all oak species to a text file. Contains docstrings for debugging

scope.py - A script exemplifyig the theory of variable scope by using local and global variables in various ways

sysargv.py - A script exemplifing the use of sys.arg and how it behaves

test_control_flow.py - Some functions exemplifying the use of control statements with embedded docscripts for debugging

tuple.py - Prints the latin name, common name and mass of various bird species

using_name.py - Shows how to distinguish between the module being run directly or called from another module
**********************************************************************

Results directory missing!

Creating Results directory...

Found 21 code files: lc2.py, boilerplate.py, basic_csv.py, cfexercises2.py, align_seqs_better.py, dictionary.py, debugme.py, scope.py, cfexercises1.py, tuple.py, basic_io.py, lc1.py, oaks_debugme.py, oaks.py, loops.py, using_name.py, align_seqs.py, sysargv.py, align_seqs_fasta.py, control_flow.py, test_control_flow.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file lc2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Creates lists of both months in 1910 where rainfall was less than 50mm and
    month, rainfall tuples where rainfall exceeded 100mm. This is done via
    both loops and list comprehensions """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## Imports ##

# None

## Constants ##

# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )


## Functions##

def is_rainfall_low(month):
    """ Finds which months had less than 50mm of rainfall """
    if month[1] < 50:
        return month

def is_rainfall_high(month):
    """ Finds which months had more than 100mm of rainfall """
    if month[1] > 100:
        return month

##############


# Creates a list of the month and amount of rainfall for months where rainfall
# exceeded 100mm using loops

High_rainfall = [] # Creates an empty list
for month in rainfall:
    if is_rainfall_high(month): # Sends to is_rainfall_high
        High_rainfall.append(month) # Appends the month and rainfall to list where True
print (High_rainfall) # Prints the new list

# Creates a list of all months in 1910 where rainfall was below 50mm using loops

Low_rainfall = []
for month in rainfall:
    if is_rainfall_low(month):
        Low_rainfall.append(month[0]) # Appends only the month not rainfall
print (Low_rainfall)

# Creates a list of the month and amount of rainfall for months where rainfall
# exceeded 100mm using list comprehension

# Sends the month to is_rainfall_high for each month in the tuple, and creates a 
# list of the returned months
High_rainfall_lc = [month for month in rainfall if is_rainfall_high(month)]
print (High_rainfall)

# Creates a list of all months in 1910 where rainfall was below 50mm 
# using list comprehension

# Same as above, but sends to is_rainfall_low and returns only the month name
Low_rainfall_lc = [month[0] for month in rainfall if is_rainfall_low(month)]
print (Low_rainfall_lc)
**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
['MAR', 'SEP']
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
['MAR', 'SEP']

**********************************************************************

Code ran without errors

Time consumed = 0.02965s

======================================================================
Inspecting script file boilerplate.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Description of this program or application.
    You can use several lines"""

__appname__ = '[application name here]'
__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'
__license__ = "Licence for this code/program"

## imports ##

import sys # module to interface out program with the operating system

## constants ##

## functions ##

def main(argv):
    """ Main entry point of the program """
    print ('This is a boilerplate')
    return 0

################

## This means the code will not run when it's imported, but the functions can still be called.
if __name__ == "__main__": #Makes sure the first system argument is the\
    # name of the program
    """ Makes sure the "main" function is called from command line"""
    status = main(sys.argv)
    sys.exit(status)**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.02649s

======================================================================
Inspecting script file basic_csv.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Demonstates the usage of the csv library to read, manipulate
    and write to csv files """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import csv

## CONSTANTS ##

# None

## FUNCTIONS ##

# None

################

# Read a file containing:
# 'Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (kg)'
f = open ('../Data/testcsv.csv', 'r') # Opens a readable file

csvread = csv.reader(f) # Places the csv into an obect called csvread
temp = [] # Creates an empty list
temp.append(next(csvread)) # Appends the header row to temp and skips it so
                           # it is not read in the loop
for row in csvread: 
    temp.append(tuple(row)) # Appends the row to the temp list as a tuple
    print(row)
    print('The species is', row[0]) # Row[0] references the first coloumn in the row

f.close # Close the file

## Write a file containing only species name and Body mass

f = open('../Data/testcsv.csv', 'r') # Opens a readable file
g = open('../Output/bodymass.csv', 'w') # Creates a writeable file

csvread = csv.reader(f)
csvwrite = csv.writer(g)
# Places the first row into the object header and skips to the next row
header = (next(csvread)) 
# Writes the 1st and 3rd objects in header to the output file
csvwrite.writerow([header[0], header[4]])
for row in csvread:
    print (row)
    print ("Species %s has a mass of %s" % (row[0], row[4]))
    csvwrite.writerow([row[0], row[4]]) # Writes only the 1st and 3rd columns

# Closes both files
f.close()
g.close()**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['Daubentonia_madagascariensis', 'Chiromyiformes ', 'Daubentoniidae', 'Madagascar', '2.7']
The species is Daubentonia_madagascariensis
['Allocebus_trichotis', 'Lemuriformes', 'Cheirogaleidae', 'Madagascar', '0.1']
The species is Allocebus_trichotis
['Avahi_laniger', 'Lemuriformes', 'Indridae', 'America', '1.03']
The species is Avahi_laniger
['Avahi_occidentalis', 'Lemuriformes', 'Indridae', 'Madagascar', '0.814']
The species is Avahi_occidentalis
['Avahi_unicolor', 'Lemuriformes', 'Indridae', 'Am
**********************************************************************

Code ran without errors

Time consumed = 0.03242s

======================================================================
Inspecting script file cfexercises2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Additional exercises detailing the usage of 
    control statements and control flow """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## Imports ##

import sys

## Constants ##

# None

## Functions ##

def foo1(x=64): # x=num gives the default value for x in the function if no value \
    # is specified before running
    """ Gives the sqrt of a number """
    return x ** 0.5

def foo2(x=200, y=20):
    """ Gives the higher of two numbers """
    if x > y:
        return x
    return y

def foo3(x=3, y=1, z=2):
    """ Sorts 3 numbers into numerical order """
    if x > y: # If x is numerically larger than y
        tmp = y # Copies y into a placeholder object
        y = x # Copies x over y
        x = tmp # Makes x become the original value of y
    if x > z:
        tmp = z
        z = x
        x = tmp
    if y > z:
        tmp = z
        z = y
        y = tmp
    return [x, y, z]

def foo4(x=4):
    """ Gives x!"""
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return result

def foo5(x=4): #recursive function
    """ Gives x! using a recursive function """
    if x == 1:
        return 1
    return x * foo5(x - 1) # Multiplies x by the result of running the function \
    # With a value of x 1 lower than the current iteration

def main(argv):
    """ Main entry point of the program """
    print(foo1(64))
    print(foo1(63))
    print(foo2(200, 1))
    print(foo2(5, 5.01))
    print(foo3(3, 2, 1))
    print(foo3(24, 365, 60))
    print(foo4(1))
    print(foo4(12))
    print(foo5(1))
    print(foo5(12))
    return 0 ## Gives a value for status

####################

if __name__ == "__main__":
    """ Makes sure the "main" function is called from command line"""
    status = main(sys.argv)
    sys.exit(status) ## 0 causes the program to terminate
**********************************************************************

Testing cfexercises2.py...

cfexercises2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
8.0
7.937253933193772
200
5.01
[1, 2, 3]
[24, 60, 365]
1
479001600
1
479001600

**********************************************************************

Code ran without errors

Time consumed = 0.02970s

======================================================================
Inspecting script file align_seqs_better.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Compares two DNA base sequences and finds the position at which they most 
    closely match. Where there are multiple best matches, it records all of them.
    The best matches are outputted to a file in ../Output/ """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## Imports ##

import pandas # Imports pandas, a library that interacts with csvs

## Constants ##

# Creates a data frame from the csv with the two sequences in it
seqs = pandas.read_csv('../Data/SeqShort.csv', sep = ',', header = None)

# Assigns each sequence to be matched to a variable
seq1 = seqs.loc[0][0]
seq2 = seqs.loc[0][1]

## Functions ##

def calculate_score(s1, s2, l1, l2, startpoint):
    """ Computes a score by returning the number of matches between two sequences
    starting an from arbitrary startpoint (chosen by user)"""
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2): # Runs the loop as many times as the l2
        if (i + startpoint) < l1: # Checks to see if l1 has been exceeded
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

###############

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swaps the two lengths

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1
best_scores = dict() # Creates an empty dictionary

for i in range(l1):
    z = calculate_score(s1, s2, l1, l2, i)
    if z >= my_best_score:
        my_best_align = "." * i + s2 # Makes a visual representation of match position
        my_best_score = z 
        # Best score plus its allignment is added to the dictionary
        best_scores.setdefault(my_best_score, []).append(i)

with open ('../Output/Seq_matches.txt', 'w') as data:
    data.write(str(best_scores)) # Writes the best_scores dictionary to a text file

print(my_best_align)
print(s1)
print("Best score:", my_best_score)**********************************************************************

Testing align_seqs_better.py...

align_seqs_better.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5
 
.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2
 
..*---------
..CAATTCGGAT
ATCGCCGGATTACGGG
1
 
...--------*-
...CAATTCGGAT
ATCGCCGGATTACGGG
1
 
....*---------
....CAATTCGGAT
ATCGCCGGATTACGGG
1
 
.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG
2
 
......--***--*--
......CAATTCGGAT
ATCGCCGGATTACGGG
4
 
.......-*-*-***-
.......CAATTCGGAT
ATCGCCGGATTACGGG
5
 
........------**
........CAATTCGGAT
ATCGCCGGATTACGGG
2
 
.........--*---*
.........CAATTCGGAT
ATCGCCGG
**********************************************************************

Code ran without errors

Time consumed = 0.59365s

======================================================================
Inspecting script file dictionary.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Creates a dictionary of species' latin names sorted by Order """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## Imports ##

# None

## Constants ##

# A list of (latin name, Order) tuples
taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

## Functions ##

# None

###############
taxa_dic = {} # Creates an empty dictionary
for species in taxa:
        # For each species, appends the Order as a new key if it does not exist\
        # Attaches latin name to correct Order 
        taxa_dic.setdefault(species[1], []).append(species[0])
print (taxa_dic)

**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
{'Carnivora': ['Lyacon pictus', 'Arctocephalus gazella', 'Canis lupus'], 'Rodentia': ['Gerbillus henleyi', 'Peromyscus crinitus', 'Mus domesticus', 'Cleithrionomys rutilus'], 'Afrosoricida': ['Microgale dobsoni', 'Microgale talazaci'], 'Chiroptera': ['Myotis lucifugus']}

**********************************************************************

Code ran without errors

Time consumed = 0.03254s

======================================================================
Inspecting script file debugme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" A script with inbuilt bugs to demonstrate debugging practices """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## imports ##

import ipdb

## constants ##

#None

## functions ##

def createabug(x):
    """ A function that creates an impossible number. Contains a breakpoint
    for debuging """
    y = x**4
    z = 0.
    ipdb.set_trace() # Adds a breakpoint at which to start debugging
    y = y/z # Creates an impossible number
    return y

##############

createabug(25)**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
]0;IPython: Week2/Code> [0;32m/home/mhasoba/Documents/Teaching/IC_CMEE/2018-19/Coursework/StudentRepos/RachelBates_RLB18/Week2/Code/debugme.py[0m(24)[0;36mcreateabug[0;34m()[0m
[0;32m     22 [0;31m    [0mz[0m [0;34m=[0m [0;36m0.[0m[0;34m[0m[0m
[0m[0;32m     23 [0;31m    [0mipdb[0m[0;34m.[0m[0mset_trace[0m[0;34m([0m[0;34m)[0m [0;31m# Adds a breakpoint at which to start debugging[0m[0;34m[0m[0m
[0m[0;32m---> 24 [0;31m    [0my[0m [0;34m=[0m [0my[0m[0;34m
**********************************************************************

Code ran without errors

Time consumed = 0.65004s

======================================================================
Inspecting script file scope.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" A script exemplifyig the theory of variable scope by using local 
    and global variables in various ways """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

# None

## CONSTANTS ##

# None

################

_a_global = 10 # Define local variable

def a_function():
    """ Gives local values to variables and prints them """
    _a_global = 5 # Redefine the variable locally to a_function
    _a_local = 4
    print("Inside the function, the value is ", _a_global) 
    print("Inside the function, the value is ", _a_local)
    return None

a_function()

# Will still print "10" as _a_global only = 5 within a_function
print("Outside the function, the value is ", _a_global)

## Then try this

_a_global = 10 # Globally defines the variable

def a_function():
    """ Changes _a_global to a global variable, assigns new values to it and
    _a_local and prints them """
    # Makes _a_global a global function, meaning local changes have global effects
    global _a_global 
    # Locally defines/redefines the variables
    _a_global = 5
    _a_local = 4
    print("Inside the function, the value is ", _a_global)
    print("Inside the function, the value is ", _a_local)
    return None

a_function()
# Now prints 5, as the local changes were carried
print("Outside the function, the value is ", _a_global)
**********************************************************************

Testing scope.py...

scope.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Inside the function, the value is  5
Inside the function, the value is  4
Outside the function, the value is  10
Inside the function, the value is  5
Inside the function, the value is  4
Outside the function, the value is  5

**********************************************************************

Code ran without errors

Time consumed = 0.03022s

======================================================================
Inspecting script file cfexercises1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Exercises detailing the usage of control statements and control flow """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

# Prints hello 15 times
for i in range(3, 17):
    print ('hello')

# Prints hello for each number exactly divisible by 3 between 0 and 12 (4 times)
for j in range(12):
    if j % 3 == 0:
        print ('hello')

# Prints hello for each number that gives a remainder of three when dividing \
# by 4 or the same when dividiby by 5. Prints 5 times. 
for j in range(15):
    if j % 5 == 3:
        print ('hello')
    elif j % 4 == 3:
        print ('hello')

# If z is less than 15, hello prints then 3 is added to z. Prints 4 times.
z = 0
while z != 15:
    print ('hello')
    z = z + 3

# Runs from initial value of z (12) until 100.
z = 12
while z < 100:
    if z == 31: # When z = 31
        for k in range(7):
            print ('hello') # Prints "hello" for each value of k (7 times)
    elif z == 18:
        print ('hello') # Prints hello when z = 18
    z = z +1 # Adds 1 to z
**********************************************************************

Testing cfexercises1.py...

cfexercises1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello

**********************************************************************

Code ran without errors

Time consumed = 0.02827s

======================================================================
Inspecting script file tuple.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Prints the latin name, common name and mass of various bird species """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## Imports ##

# None

## Constants ##

# A tuple of tuples of bird attributes by species
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

## Functions ##

# None

###############

# Prints the attributes for each species using loops
for species in birds:
    print (species)

# Prints the attributes for each species using list comprehension
all_birds = [print(species) for species in birds]
**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
('Passerculus sandwichensis', 'Savannah sparrow', 18.7)
('Delichon urbica', 'House martin', 19)
('Junco phaeonotus', 'Yellow-eyed junco', 19.5)
('Junco hyemalis', 'Dark-eyed junco', 19.6)
('Tachycineata bicolor', 'Tree swallow', 20.2)
('Passerculus sandwichensis', 'Savannah sparrow', 18.7)
('Delichon urbica', 'House martin', 19)
('Junco phaeonotus', 'Yellow-eyed junco', 19.5)
('Junco hyemalis', 'Dark-eyed junco', 19.6)
('Tachycineata bicolor', 'Tree swallow', 20.2)

**********************************************************************

Code ran without errors

Time consumed = 0.03031s

======================================================================
Inspecting script file basic_io.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Several blocks of script demonsrating the ways to input and output data
        from files into python, or to files out of python """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import pickle

#######################

###################
# FILE INPUT
###################

# Open a file for reading
f = open('../Sandbox/test.txt', 'r') ## r = read
# use implicit for loop:
# if the object is a file, python will cycle over lines
for line in f: # Prints each line separately
    print(line)

# Close the file
f.close()

# Same example, skip blank lines
f = open('../Sandbox/test.txt', 'r')
for line in f:
    if len(line.strip()) > 0: ## Strips the line of all\
        ## spaces/newline characters then checks the length
        print(line) # Prints only lines containing non-space charcters

f.close()

##################
# FILE OUTPUT
##################

# Save the elements of a list to a file
list_to_save = range(100)

# Creates a file to save the list to
f = open('../Sandbox/testout.txt', 'w') ## w = write
for i in list_to_save:
    f.write(str(i) + '\n') ## Converts each object to a string, adds a new line\
    # at the end and writes it to the file

f.close()

###################
# STORING OBJECTS
###################

# To save an object (even complex) for later use

my_dictionary = {"a key": 10, "another key": 11}

#requires pickles (imported at the top of the script)

f = open('../Sandbox/testp.p', 'wb') ## note the b: accept binary files
pickle.dump(my_dictionary, f) # Places the dictionary in pickle (essentially a\
# temporary file)

f.close()

## Load the data again
f = open('../Sandbox/testp.p', 'rb')
another_dictionary = pickle.load(f) # Places the contents of pickle in a new dictionary
f.close()

print(another_dictionary)**********************************************************************

Testing basic_io.py...

basic_io.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
First Line

Second Line



Third Line



Fourth Line

First Line

Second Line

Third Line

Fourth Line

{'a key': 10, 'another key': 11}

**********************************************************************

Code ran without errors

Time consumed = 0.03692s

======================================================================
Inspecting script file lc1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Creates lists of one attribute for several bird species in one tuple """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## Imports ##

# None

## Constants ##

# A tuple of tuples of bird attributes by species
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

## Functions ##

#None

##################

## Creates a list of all the latin names for species in "birds" using loops

Birds_latin = [] # Creates an empty list
for species in birds:
    # Appends the first item in ech nested set to the new list
    Birds_latin.append(species[0]) 
print (Birds_latin) # Prints the list

# Creates a list of all the common names for species in "birds" using loops
Birds_common = []
for species in birds:
    Birds_common.append(species[1])
print (Birds_common)

# Creates a list of all the masses for species in "birds" using loops
Birds_mass = []
for species in birds:
    Birds_mass.append(species[2])
print (Birds_mass)

# Creates a list of all the latin names for species in "birds" 
# using list comprehension
# Appends the first item for each nested list to a new list
Birds_latin_lc = [species[0] for species in birds] 
print (Birds_latin_lc) # Prints the new list

# Creates a list of all the common names for species in "birds" 
# using list comprehension
Birds_common_lc = [species[1] for species in birds]
print (Birds_common_lc)

# Creates a list of all the masses for species in "birds" 
# using list comprehension
Birds_mass_lc = [species[2] for species in birds]
print (Birds_mass_lc)**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]

**********************************************************************

Code ran without errors

Time consumed = 0.02783s

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Module that checks a list of latin names to see which are oaks, 
    and exports all oak species to a text file. 
    Contains docstrings for debugging """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import csv
import sys
import doctest

## CONSTANTS ##

# None

## FUNCTIONS ##

def is_an_oak(name):
    """ Tests to see if the function can correctly identify oaks

    >>> is_an_oak("Quercus, robur")
    True

    >>> is_an_oak("Fraxinus, excelsior")
    False

    >>> is_an_oak("Quercus robur")
    False

    >>> is_an_oak("Quercs, robur")
    False

    >>> is_an_oak("Quercusoba, rubinous")
    False

    >>> is_an_oak("robor, Quercus")
    False

    >>> is_an_oak("QUERCUS, ROBOR")
    True

    >>> is_an_oak("quercus, robor")
    True

    >>> is_an_oak(365)
    False

    >>> is_an_oak(True)
    False

    >>> is_an_oak("Pseudoquercus, confiscuous")
    False

    >>> is_an_oak(" Quercus, robor")
    True

    """
    name = str(name).lower() # Turns the name into a string
    name = name.lstrip() # Strips any spaces from the beginning of the string
    name = name.split(",")[0] # Removes anything after the comma in the name
    if len(name)!=7: # Ensures any name of the incorrect length returns false
        return False
    return name.startswith("quercus") # Returns true if the name begins with "quercus"

def main(argv):
    """ Main entry point of the program """ 
    f = open('../Data/TestOaksData.csv','r')
    g = open('../Output/JustOaksData.csv','w') # Creates an output csv
    taxa = csv.reader(f) # Reads the data from a csv into the object taxa
    header = next(taxa) # Skips the header line and outputs it to header
    csvwrite = csv.writer(g) # Makes an object for the output csv
    csvwrite.writerow(header) # Appends the header to the output file   
    oaks = set() # Creates an empty set
    for row in taxa:
        print(row)
        print ("The genus is: ") 
        print(row[0] + '\n')
        if is_an_oak(row[0]): # Sends the row to is_an_oak, if True then run this
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]]) # Writes the name to the output file
    f.close()
    g.close()
    return 0

#doctest.testmod() #Commented out doctest, uncomment to allow the doctests to run
if (__name__ == "__main__"):
    # Runs main(argv) if this is run directly rather than being imported
    status = main(sys.argv)**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['Quercus', ' robur']
The genus is: 
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus

FOUND AN OAK!


**********************************************************************

Code ran without errors

Time consumed = 0.06728s

======================================================================
Inspecting script file oaks.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Finds just those species that are oaks from a list of species' latin names """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## Imports ##

# None

## Constants ##

# A list of latin names
taxa = [ 'Quercus robur',
         'Fraxinus excelsior',
         'Pinus sylvestris',
         'Quercus cerris',
         'Quercus petraea',
       ]

## Functions ##

# Returns the species name (lower case) if it is an oak
def is_an_oak(name):
    """ Checks to see if the latin name begins with Quercus """
    return name.lower().startswith('quercus ') # Places the name in lowercase first

################

# Using FOR loops

oaks_loops = set() # Creates an empty set
for species in taxa:
    if is_an_oak(species): # Runs is_an_oak on each item
        oaks_loops.add(species) # If return is True, adds the species to the set
print(oaks_loops) # Prints the oak species latin names

# Using List Comprehension
# Does the same as the for loop, but within one line of code
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)

# Get names in UPPER CASE using FOR loops

oaks_loops = set() # Makes an empty set
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper()) # Adds the species name of any identified\
        # Oaks in upper case
print(oaks_loops)

# Get names in UPPER CASE using List Comprehensions
# Does the same as above but via list comprehension
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)
**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
{'Quercus robur', 'Quercus petraea', 'Quercus cerris'}
{'Quercus robur', 'Quercus petraea', 'Quercus cerris'}
{'QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'}
{'QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'}

**********************************************************************

Code ran without errors

Time consumed = 0.02931s

======================================================================
Inspecting script file loops.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Some functions exemplifying the use of loops statements """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

# None

## CONSTANTS ##

# None

## FUNCTIONS ##

# None

#################

## FOR loops in python

# Prints 0-4 on newlines
for i in range(5):
    print (i)

# Prints the list item by item
my_list = [0, 2, "geroimo!", 3.0, True, False]
for k in my_list:
    print(k)

# Prints the sum of each number plus the total of all numbers prior in the list
total = 0
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total = total + s
    print(total)

## WHILE loops in python

# Prints 1-100 on newlines
z = 0
while z < 100:
    z = z + 1
    print(z)

# Prints the script forever
b = True
while b:
    print("GERONIMO! Infinite loop! ctrl+c to stop!")
**********************************************************************

Testing loops.py...

loops.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
0
1
2
3
4
0
2
geroimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
GERONIMO! Infinite loop! ctrl+c to stop!
GERONIMO! Infinite loop! ctrl+c to stop!
GERONIMO! Infinite loop! ctrl+c to stop!
GERONIMO! Infinite loop! ctrl+c 
**********************************************************************

Code ran without errors

Time consumed = 10.25942s

======================================================================
Inspecting script file using_name.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Shows how to distinguish between the module being run directly or called from another module """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

# None

## CONSTANTS ##

# None

## FUNCTIONS ##

# None

###############


if __name__ == '__main__': # If the name of this programe is the same as the\
    # name of the main program being run
    print ('This program is being run by itself')
else:
    print ('I am being imported from another module')
**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This program is being run by itself

**********************************************************************

Code ran without errors

Time consumed = 0.08721s

======================================================================
Inspecting script file align_seqs.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Compares two DNA base sequences and finds the position at which they most closely match """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## Imports ##

import pandas # Imports pandas, a library that interacts with csvs

## Constants ##

# Creates a data frame from the csv with the two sequences in it
seqs = pandas.read_csv('../Data/SeqShort.csv', sep = ',', header = None)

# Assigns each sequence to be matched to a variable
seq1 = seqs.loc[0][0]
seq2 = seqs.loc[0][1]

## Functions ##

def calculate_score(s1, s2, l1, l2, startpoint):
    """ Computes a score by returning the number of matches between two sequences
    starting an from arbitrary startpoint (chosen by user)"""
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2): # Runs the loop as many times as the l2
        if (i + startpoint) < l1: # Checks to see if l1 has been exceeded
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched) # Shows where the base matches are       
    print("." * startpoint + s2) # Shows where s1 is being compared to s2
    print(s1)
    print(score) 
    print(" ")

    return score

###############

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swaps the two lengths

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the first alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score: # Only runs if the best score is exceeded
        my_best_align = "." * i + s2 # Makes a visual representation of match position
        my_best_score = z 
print(my_best_align)
print(s1)
print("Best score:", my_best_score)**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5
 
.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2
 
..*---------
..CAATTCGGAT
ATCGCCGGATTACGGG
1
 
...--------*-
...CAATTCGGAT
ATCGCCGGATTACGGG
1
 
....*---------
....CAATTCGGAT
ATCGCCGGATTACGGG
1
 
.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG
2
 
......--***--*--
......CAATTCGGAT
ATCGCCGGATTACGGG
4
 
.......-*-*-***-
.......CAATTCGGAT
ATCGCCGGATTACGGG
5
 
........------**
........CAATTCGGAT
ATCGCCGGATTACGGG
2
 
.........--*---*
.........CAATTCGGAT
ATCGCCGG
**********************************************************************

Code ran without errors

Time consumed = 0.55133s

======================================================================
Inspecting script file sysargv.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" A script exemplifing the use of sys.arg and how it behaves """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import sys

## CONSTANTS ##

# None

## FUNCTIONS ##

# None

################

#sys.arg[0] is always the name of the module itself
print ("This is the name of the script: ", sys.argv[0]) 
print ("Number of arguments: ", len(sys.argv))
print ("The arguments are: ", str(sys.argv))
**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.04234s

======================================================================
Inspecting script file align_seqs_fasta.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Compares two DNA base sequences from two input files
    and finds the position at which they most closely match """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## Imports ##

import csv
import sys

## Constants ##

if len(sys.argv) == 3: # If user has entered two files
    with open (sys.argv[1]) as f: # Opens first file as a list\
        #and removes newline characters
        seq1 = [line.rstrip('\n') for line in f]
    
    seq1[0:len(seq1)] = [''.join(seq1[0:len(seq1)])] # Merges all list items
    seq1 = seq1[0] # Makes an object be just the string in the list

    with open (sys.argv[2]) as g:# Opens second file as a list\
        #and removes newline characters
        seq2 = [line.rstrip('\n') for line in g]

    seq2[0:len(seq2)] = [''.join(seq2[0:len(seq2)])] # Merges all list items
    seq2 = seq2[0]# Makes an object be just the string in the list

else: #If no user inputs or incorrect number of inputs
    with open ('../Data/407228326.fasta') as f:# Opens first default file as a \
        #list and removes newline characters
        seq1 = [line.rstrip('\n') for line in f]
    
    seq1[0:len(seq1)] = [''.join(seq1[0:len(seq1)])] # Merges all list items
    seq1 = seq1[0]# Makes an object be just the string in the list

    with open ('../Data/407228412.fasta') as g:# Opens second default file as a\ 
        #list and removes newline characters
        seq2 = [line.rstrip('\n') for line in g]

    seq2[0:len(seq2)] = [''.join(seq2[0:len(seq2)])] # Merges all list items
    seq2 = seq2[0]# Makes an object be just the string in the list



## Functions ##

def calculate_score(s1, s2, l1, l2, startpoint):
    """ Computes a score by returning the number of matches between two sequences
    starting an from arbitrary startpoint (chosen by user)"""
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2): # Runs the loop as many times as the l2
        if (i + startpoint) < l1: # Checks to see if l1 has been exceeded
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    return score

###############

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swaps the two lengths

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the first alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score: # Only runs if the best score is exceeded
        my_best_align = "." * i + s2 # Makes a visual representation of match position
        my_best_score = z 
print(my_best_align)
print(s1)
print("Best score:", my_best_score)
**********************************************************************

Testing align_seqs_fasta.py...

align_seqs_fasta.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
.............................................>gi|407228326|dbj|AB690564.1| Homo sapiens x Mus musculus hybrid cell line GM11713 FHIT gene, intron 3, partial sequence, including PATRR3 regionAAAAAAACAAAAAGATACATATATATGATATATCTGATATATGATATATATATGATATATCTGATATATGATATATATATGATATATCTGATATATGATATATATATGATATATCTGATATATGATATATATATGATATATCTGATATATATACATATGGTATACATGAGATACATCATATGTATATATGGTATACATGAGATACATCATATGTATATATGGTATACATGAGATACATCATATGTATATATGGTATACATGAGATACATCATATGTATACATGAGATACATCATATGTATACATGAGATAC
**********************************************************************

Code ran without errors

Time consumed = 3.69689s

======================================================================
Inspecting script file control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Some functions exemplifying the use of control statements """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import sys # module to interface out program with the operating system

## CONSTANTS ##

#None

## FUNCTIONS ##

def even_or_odd(x=0): # x = num gives a difault value if there's no input
    """Find whether a number (x) is even or odd."""
    if x % 2 == 0: # is x exactly divisible by 2
        return "%d is Even!" % x
    return "%d is Odd!" % x

def largest_divisor_five(x=120):
    """Find which is he largest divisor of x among 2,3,4,5."""
    largest = 0 
    if x % 5 == 0: # Is x exactly divisible by 5
        largest = 5 # If so, set largest as 5
    elif x % 4 == 0:
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else:
        return "No divisor found for %d!" % x # If no divisor <=5 found
    return "The largest divisor of %d is %d" % (x, largest)

def is_prime(x=70):
    """Find whether an interger is prime"""
    for i in range(2, x): # Starts the loop at 2
        if x % i == 0: # If x divides exactly by i
            print("%d is not a prime: %d is a divisor" % (x,i))
                #Print formatted text "%d %s %f %e" % (20, "30", 0.0003, 0.00003)
            return False
    print ("%d is a prime!" % x)
    return True

def find_all_primes (x=22):
    """Find all the primes up to x"""
    allprimes = [] # Creates an empty list
    for i in range(2, x + 1):
        if is_prime(i): # Sends i to is_prime function
            allprimes.append(i) # Appends to list if i_prime returns True
    print("There are %d primes between 2 and %d" % (len(allprimes), x))
    return allprimes

def main(argv):
    """ Main entry point of the program """
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0 ## Gives a value for status

#####################

if __name__ == "__main__":
    """ Makes sure the "main" function is called from command line"""
    status = main(sys.argv)
    sys.exit(status) ## 0 causes the program to terminate
**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is 
**********************************************************************

Code ran without errors

Time consumed = 0.03143s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Some functions exemplifying the use of control statements 
    with embedded docscripts for debugging """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import sys # module to interface out program with the operating system
import doctest

## CONSTANTS ##

# None

## FUNCTIONS ##

def even_or_odd(x=0): # x = num gives a difault value if there's no input
    """Find whether a number x is even or odd.

    >>> even_or_odd(10)
    '10 is Even!'

    >>> even_or_odd(5)
    '5 is Odd!'

    whenever a float is provided, then the closest integer is used:    
    >>> even_or_odd(3.2)
    '3 is Odd!'

    in case of negative numbers, the positive is taken:    
    >>> even_or_odd(-2)
    '-2 is Even!'

    """
    if x % 2 == 0: # is x exactly divisible by 2
        return "%d is Even!" % x
    return "%d is Odd!" % x

def largest_divisor_five(x=120):
    """Find which is he largest divisor of x among 2,3,4,5."""
    largest = 0
    if x % 5 == 0: # Is x exactly divisible by 5
        largest = 5 # If so, set largest as 5
    elif x % 4 == 0:
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else:
        return "No divisor found for %d!" % x # If no divisor <=5 found
    return "The largest divisor of %d is %d" % (x, largest)

def is_prime(x=70):
    """Find whether an interger is prime"""
    for i in range(2, x): # Starts the loop at 2
        if x % i == 0: # If x divides exactly by i
            print("%d is not a prime: %d is a divisor" % (x,i))
                #Print formatted text "%d %s %f %e" % (20, "30", 0.0003, 0.00003)
            return False
    print ("%d is a prime!" % x)
    return True

def find_all_primes (x=22):
    """Find all the primes up to x"""
    allprimes = [] # Creates an empty list
    for i in range(2, x + 1):
        if is_prime(i): # Sends i to is_prime function
            allprimes.append(i) # Appends to list if i_prime returns True
    print("There are %d primes between 2 and %d" % (len(allprimes), x))
    return allprimes

## Commented out to avoid just running the script. We only want to run tests

#def main(argv):
#    """ Main entry point of the program """
#    print(even_or_odd(22))
#    print(even_or_odd(33))
#    print(largest_divisor_five(120))
#    print(largest_divisor_five(121))
#    print(is_prime(60))
#    print(is_prime(59))
#    print(find_all_primes(100))
#    return 0 ## Gives a value for status

#####################

#if __name__ == "__main__":
#    """ Makes sure the "main" function is called from command line"""
#    status = main(sys.argv)
#    sys.exit(status) ## 0 causes the program to terminate

doctest.testmod() ## Runs the script with embedded tests
**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.07136s

======================================================================
======================================================================
Finished running scripts

Ran into 0 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 100

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!