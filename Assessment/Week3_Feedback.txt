Starting weekly assessment for Rachel, Week3

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 19.33 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week6, Week1, Week7, Assessment, HPC, Week5, Week2, Week4, .git, Week3, Project, MiniProject

Found the following files in parent directory: README.txt, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~ 
*.tmp
*.aux 
*.dvi 
*.log 
*.nav 
*.out 
*.snm 
*.toc
*py[cod] 
*.class
_pycache_
*.pyc
*.bbl
*.blg
-
.ipynb_checkpoints
*.synctex.gz
**********************************************************************

Found README in parent directory, named: README.txt

Printing contents of README.txt:
**********************************************************************
My CMEE Coursework Repository
Created by Rachel Bates 02/10/18

A repository containing all code and example data from a 9 week intro to biological computing masters. 

Week 1:		Introduction to Unix, LaTeX and Shell Scripting
Week 2:		Introduction to Python3
Week 3:		Introduction to R
Week 4:		Stats in R
Week 5:		GIS in QGIS
Week 6:		Genomics and Bioinformatics
Week 7:		Python 2
Week 8:		MiniProject: Model fitting miniproject
Week 9: 	HPC: High Performance Computing Week
Assessment: 	Outputs from an auto assessing Python script
Project:	Initial work for the MRes research project

Languages used:
- Bash
- LaTeX
- R
- Python 3

Specific versions used are specified within individual sub-directories' README documents. The README also contains details of any packages needed to run those scripts (none needed if none specified).

Directory structures for each week will be as follows (may change slightly depending on the content of the week):
Code:	 	All code
Data:		All files to be used as inputs for scripts
Output:		Where any files generated by scripts will be placed
Sandbox: 	Misc files and outputs used while learning and experimenting
**********************************************************************

======================================================================
Looking for the weekly directories...

Found 7 weekly directories: Week1, Week2, Week3, Week4, Week5, Week6, Week7

The Week3 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK3...

Found the following directories: Code, WriteUp, Data, Output, Sandbox

Found the following files: README.txt

Checking for readme file in weekly directory...

Found README in parent directory, named: README.txt

Printing contents of README.txt:
**********************************************************************
Week three of CMEE Course Work
AUTHOR: Rachel Bates
DATE CREATED: 15/10/18

This directory contains R scripts used to learn the basics of the R language, as well as example data used to run those scripts.

Bash Version used: 4.3.48(1)

LaTeX Version used: TeX Live 2015

Required LaTeX packages:
	-graphicx

R Version used: 3.2.3

Required R packages:
	-reshape2
	-tidyr
	-dplyr
	-maps
	-ggplot2
	-lattice
	-plyr

Python Version used: 3.5.2

Required Python packages:
	-sys
	-pandas
	-re
	-math
	-time
	-numpy

Sub-Directories:

Code:	 	All code
Data:		All files to be used as inputs for scripts
Output:		Where any files generated by scripts will be placed
Sandbox: 	Misc files and outputs used while learning and experimenting

Scripts:

apply1.R - Script to show example usage of apply

apply2.R - Script to show more examples of apply usage

basic_io.R - A simple script to illustrate R input-output.

boilerplate.R - A boilerplate R script

break.R - Simple code to demonstrate the use of break within while loops

browse.R - Demonstrates the use of browse() 

control.R - Some code exemlifying control flow constructs in R

DataWrang.R - Using base R functions to wrangle a dataset from wide to long format

DataWrangTidy.R - Wrangles a badly formatted dataset into a long format with correct datatypes using Tidyr and Dplyr

get_TreeHeight.R - This function calculates heights of trees given distance of each tree from its base and angle to its top, using  the trigonometric formula.

get_TreeHeight.py - This function calculates heights of trees given distance of each tree from its base and angle to its top, using  the trigonometric formula.

Girko.R - Generates a girko plot of random data using ggplots

Mapping.R - Loads a set of location data for various species, and plots these coordinates on a world map

MyBars.R - Creates a bar plot using ggplots

next.R - Simple code to demonstrate the use of next in loops

plotLin.R - Plots a scatterplot of random numbers and adds a regression line using ggplots

PP_Lattice.R - Generates density plots and key descriptive stats for predator/prey masses per type of feeding interaction. Outputs the results as a pdf for the graphs and a csv file of descriptive stats

PP_Regress.R - Plots predator mass against prey mass for each feeding interaction type, and gives lm estimates for each lifestage. Calculates true lm values for each lifestage, for each feeding interaction and outputs to a csv.

preallocate.R - Script demonstarting the speed benefits of pre-allocating variables

run_get_TreeHeight.sh - Runs get_TreeHeight.R and get_TreeHeight.py

sample.R - Runs a simulation that involves sampling from a population

TAutoCorr.R - Looks at the correlation between temperatures in FLorida in subsequent years. Compares these correlations to those between non-sequential years to determine how independant they are. 

TreeHeight.R - This function calculates heights of trees given distance of each tree from its base and angle to its top, using  the trigonometric formula 

try.R - Demonstrates usage of the try function

Vectorize.sh - Compares R and Python run times for two scripts

Vectorize1.R - Shows the speed differences between using loops in R and pre-defined functions that call from C

Vectorize2.R - Runs the stochastic (with gaussian fluctuations) Ricker Eqn. using nested loops and without, showing the speed difference.

Vectorize1.py - Shows the speed differences between using loops in python and vectorised solutions

Vectorize2.py - Runs the stochastic (with gaussian fluctuations) Ricker Eqn. using nested loops and without, showing the speed difference.

**********************************************************************

Results directory missing!

Creating Results directory...

Found 30 code files: browse.R, PP_Regress.R, Vectorize2.py, apply1.R, sample.R, run_get_TreeHeight.sh, get_TreeHeight.py, Mapping.R, Vectorize.sh, boilerplate.R, TreeHeight.R, PP_Lattice.R, next.R, Girko.R, Vectorize1.R, break.R, plotLin.R, basic_io.R, Vectorize1.py, try.R, apply2.R, get_TreeHeight.R, TAutoCorr.R, Vectorize2.R, DataWrangTidy.R, preallocate.R, DataWrang.R, TAutoCorr.tex, MyBars.R, control.R

Found the following extra files: -
0.5 pt deducted per extra file

Current Points = 99.5

======================================================================
Testing script/code files...

======================================================================
Inspecting script file browse.R...

File contents are:
**********************************************************************
## Demonstrates the use of browse() 

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

###############

Exponential <- function(N0 = 1, r = 1, generations = 10){
  # Runs a simulation of exponential growth
  # Returns a vector of length generations
  
  N <- rep(NA, generations)    # Creates a vector of NA
  
  N[1] <- N0
  for (t in 2:generations){
    N[t] <- N[t-1] * exp(r)
    browser() # Called the browser debug
  }
  return (N)
}
plot(Exponential(), type="l", main="Exponential growth")
**********************************************************************

Testing browse.R...

Output (only first 500 characters): 

**********************************************************************
Called from: Exponential()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()

**********************************************************************

Code ran without errors

Time consumed = 0.22879s

======================================================================
Inspecting script file PP_Regress.R...

File contents are:
**********************************************************************
## Plots predator mass against prey mass for each feeding interaction type, and 
## gives lm estimates for each lifestage.
## Calculates true lm values for each lifestage, for each feeding interaction
## and outputs to a csv.

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

## Packages ##

require(ggplot2)
require(tidyr)
require(plyr)
require(dplyr)

###############

MyDF <- read.csv("../Data/EcolArchives-E089-51-D1.csv")

# Inspect the df
names(MyDF)
str(MyDF)

# Creates a plot of predator mass against prey mass by life stage, seperated by feeding type
p<-qplot(Prey.mass, Predator.mass, 
    data = MyDF, colour = Predator.lifestage, shape=I(3),
    xlab="Prey mass in grams", ylab="Predator mass in grams", log = "xy")+
theme_bw()+ # Sets the theme colour
facet_grid(Type.of.feeding.interaction ~.)+ # Separates the plots
geom_smooth(method = "lm", fullrange=TRUE, size=0.5)+ # Adds lm estimate lines
# formats the legend position and colours as well as plot size
theme(legend.position="bottom", plot.margin = unit(c(1,6,1,6),"cm"),
    legend.key = element_rect(colour = 'grey', size = 0.5, linetype='solid'),
    legend.title = element_text(face="bold"),
    # Sets line thicknesses for borders
    panel.border = element_rect(colour="grey30", size = 0.25),
    strip.background = element_rect(colour="grey30", size = 0.25),
    # Sets line thicknesses for gridlines
    panel.grid.minor = element_line(size=0.25),
    panel.grid.major = element_line(size=0.5))+
# Places the legend all on one line
guides(colour = guide_legend(nrow = 1))

pdf("../Output/PP_Regress.pdf", # Open blank pdf page using a relative path
    9, 11.7)
# Prints the created ggplot to the pdf
print(p)
graphics.off()

# Changes all units to grams
MyDF1<-subset(MyDF, MyDF$Prey.mass.unit!="mg")
MyDF2<-subset(MyDF, MyDF$Prey.mass.unit!="g")
MyDF2$Prey.mass<-MyDF2$Prey.mass/1000
MyDF2$Prey.mass.unit<-"g"
MyDF<-rbind(MyDF1, MyDF2)

# Creates a data frame with outputs from lms of all categories plotted
Outputlm.DF<-ddply(MyDF, .(Type.of.feeding.interaction, Predator.lifestage), summarize,
# Extracts the intercept of the lm
Intercept=summary(lm(MyDF$Predator.mass ~ MyDF$Prey.mass))$coef[1,1], 
# Extracts the slope of the lm
Slope=summary(lm(MyDF$Predator.mass ~ MyDF$Prey.mass))$coef[2,1],
# Extracts the r squared value
R.squared=summary(lm(MyDF$Predator.mass ~ MyDF$Prey.mass))$r.squared,
# Extracts the f statistic 
F.Statistic=summary(lm(MyDF$Predator.mass ~ MyDF$Prey.mass))$fstatistic[1],
# Calculates the overall p value using the f statistic values
Overall.Pvalue=pf(summary(lm(MyDF$Predator.mass ~ MyDF$Prey.mass))$fstatistic[1],
summary(lm(MyDF$Predator.mass ~ MyDF$Prey.mass))$fstatistic[2],
summary(lm(MyDF$Predator.mass ~ MyDF$Prey.mass))$fstatistic[3],lower.tail=FALSE) 
)


# b<-MyDF %>%
# group_by(Type.of.feeding.interaction, Predator.lifestage) %>%
# rowwise()%>%
# summarise(Intercept=summary(lm(Predator.mass ~ Prey.mass))$coef[1,1], Slope=summary(lm(Predator.mass ~ Prey.mass))$coef[2,1])

#summary(MyDF)

write.csv(Outputlm.DF, "../Output/PP_Regress_Results.csv", row.names=F)

# Outputlm.DF<-ddply(MyDF, .(Type.of.feeding.interaction, Predator.lifestage), summarize,
# # Extracts the intercept of the lm
# Intercept=summary(lm(Predator.mass ~ Prey.mass))$coef[1,1], 
# # Extracts the slope of the lm
# Slope=summary(lm(Predator.mass ~ Prey.mass))$coef[2,1]
# )**********************************************************************

Testing PP_Regress.R...

Output (only first 500 characters): 

**********************************************************************
 [1] "Record.number"               "In.refID"                   
 [3] "IndividualID"                "Predator"                   
 [5] "Predator.common.name"        "Predator.taxon"             
 [7] "Predator.lifestage"          "Type.of.feeding.interaction"
 [9] "Predator.mass"               "Prey"                       
[11] "Prey.common.name"            "Prey.taxon"                 
[13] "Prey.mass"                   "Prey.mass.unit"             
[15] "Location"                   
'data.frame
**********************************************************************

Encountered error:
Loading required package: ggplot2
Loading required package: tidyr
Loading required package: plyr
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:plyr’:

    arrange, count, desc, failwith, id, mutate, rename, summarise,
    summarize

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Warning message:
In qt((1 - level)/2, df) : NaNs produced

======================================================================
Inspecting script file Vectorize2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Runs the stochastic (with gaussian fluctuations) Ricker Eqn. using nested loops
    and without, showing the speed difference. """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'


## IMPORTS ##

import numpy as np
import time

## CONSTANTS ##

#None

## FUNCTIONS ##

def stochrick(p0=np.random.uniform(size=1000,low=.5,high=1.5),r=1.2,K=1,sigma=0.2,numyears=100):
    N=np.zeros((numyears, len(p0)))
    N[1,:]=p0
    for pop in range(0, len(p0)):
        for yr in range(1, numyears):
            N[yr,pop]=N[yr-1,pop]*np.exp(r*(1-N[yr-1,pop]/K)+np.random.normal(0,sigma,1))
    return N

def stochrickvect(p0=np.random.uniform(size=1000,low=.5,high=1.5),r=1.2,K=1,sigma=0.2,numyears=100):
    N=np.zeros((numyears, len(p0)))
    N[1,:]=p0
    for yr in range(1, numyears):
        N[yr,]=N[yr-1,]*np.exp(r*(1-N[yr-1,]/K)+np.random.normal(0,sigma,1))
    return N

################

#Time of nested loop solution
start1=time.time()
stochrick()
end1=time.time()
print("Time for loop solution to run:")
print(end1-start1,"\n")

#Time for vectorised solution
start2=time.time()
stochrickvect()
end2=time.time()
print("Time for vectorised solution to run:")
print(end2-start2, "\n")**********************************************************************

Testing Vectorize2.py...

Vectorize2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Time for loop solution to run:
0.6854143142700195 

Time for vectorised solution to run:
0.003297090530395508 


**********************************************************************

Code ran without errors

Time consumed = 0.83914s

======================================================================
Inspecting script file apply1.R...

File contents are:
**********************************************************************
## Script to show example usage of apply

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

###############

## apply: applying the same function to rows/columns of a matrix

## Build a random matrix
M <- matrix(rnorm(100), 10, 10)

## Take the mean of each row
RowMeans <- apply(M, 1, mean)
print (RowMeans)

## Now the varience
RowVars <- apply(M, 1, var)
print (RowVars)

## By column
ColMeans <- apply(M, 2, mean)
print (ColMeans)**********************************************************************

Testing apply1.R...

Output (only first 500 characters): 

**********************************************************************
 [1] -0.11151146 -0.32280044 -0.05352928  0.29086136 -0.17248618 -0.40296804
 [7] -0.07539866 -0.03581249 -0.08887543  0.15414355
 [1] 0.8733510 1.2267623 0.6768292 1.4520880 1.0585729 0.6630375 0.7906592
 [8] 0.7253693 1.0232005 0.8810013
 [1] -0.13027504 -0.49472577 -0.12915640 -0.10256754 -0.15208339  0.06068951
 [7] -0.17040337  0.05623429  0.35199301 -0.10808235

**********************************************************************

Code ran without errors

Time consumed = 0.07316s

======================================================================
Inspecting script file sample.R...

File contents are:
**********************************************************************
## Runs a simulation that involves sampling from a population

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

###############

x <- rnorm(50) #Generate your population from a normal distribution
doit <- function(x){
    x <- sample(x, replace = TRUE)
    if(length(unique(x)) > 30) { #only take mean if sample was sufficient
         print(paste("Mean of this sample was:", as.character(mean(x))))
         } 
    }

## Run 100 iterations using vectorization:
result <- lapply(1:100, function(i) doit(x))

## Or using a for loop:
result <- vector("list", 100) #Preallocate/Initialize
for(i in 1:100){
    result[[i]] <- doit(x)
    }**********************************************************************

Testing sample.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Mean of this sample was: -0.2304477490782"
[1] "Mean of this sample was: 0.0367922903170455"
[1] "Mean of this sample was: -0.127749415626457"
[1] "Mean of this sample was: -0.210441422071574"
[1] "Mean of this sample was: -0.422666123844771"
[1] "Mean of this sample was: 0.0484101148835378"
[1] "Mean of this sample was: -0.169176595853151"
[1] "Mean of this sample was: -0.031303801723982"
[1] "Mean of this sample was: -0.00159286099874349"
[1] "Mean of this sample was: -0.194854792899535"
[
**********************************************************************

Code ran without errors

Time consumed = 0.11138s

======================================================================
Inspecting script file run_get_TreeHeight.sh...

File contents are:
**********************************************************************
#!/bin/bash
#Author: Rachel Bates RLB18@Imperial.ac.uk
#Script: run_get_TreeHeight.sh
#Desc: Loads get_TreeHeight.R
#Arguments: none
#Date: 19.10.18

# Runs get_TreeHeight.R with an input
Rscript get_TreeHeight.R ../Data/trees.csv

# Runs get_TreeHeight.py with an input
python3 get_TreeHeight.py ../Data/trees.csv
**********************************************************************

Testing run_get_TreeHeight.sh...

Output (only first 500 characters): 

**********************************************************************
  [1] "Tree height is: 27.8021161438536" "Tree height is: 45.2460250644405"
  [3] "Tree height is: 14.6654828109493" "Tree height is: 14.9341751666304"
  [5] "Tree height is: 35.9703591412599" "Tree height is: 32.4102133664874"
  [7] "Tree height is: 17.4582436344144" "Tree height is: 30.1373803987097"
  [9] "Tree height is: 20.3124778877177" "Tree height is: 24.4316633466933"
 [11] "Tree height is: 27.5021323376702" "Tree height is: 25.1559006982628"
 [13] "Tree height is: 29.3924796426504" "Tre
**********************************************************************

Code ran without errors

Time consumed = 0.46784s

======================================================================
Inspecting script file get_TreeHeight.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" This function calculates heights of trees given distance of each tree 
from its base and angle to its top, using  the trigonometric formula  """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'

## IMPORTS ##

import sys
import pandas
import re
import math

## CONSTANTS ##

# None

## FUNCTIONS ##

# None

##################

# Checks to see if the user inputted a file. Gives a meaningful error message if not.
if len(sys.argv)<=1:
    sys.exit("Please enter an input file")
else:
    # Imports the file using pandas
    Trees = pandas.read_csv(sys.argv[1], sep = ',', header=0)

# f= "../Data/trees.csv"
# Trees = pandas.read_csv(f, sep = ',', header=0)

# Creates an object of just the the filename - the extension using regex.
Output = re.findall(r"/+([\w\d]+).csv", sys.argv[1])
Output = Output[0]

def TreeHeight(degrees, distance):
    heights=[] # Initialises empty list
    # Uses the trigonomic formula to calculate height
    for i in range(0,len(Trees)):
        radians=degrees[i]*math.pi/180
        height=distance[i]*math.tan(radians)
        print ("Tree height is: %g" % (height))
        heights.append(height) #Appends height to list
    return heights

# Creates a list of column names that can be referenced
columns=Trees.columns

#Creates a new column in Trees of the returned values from TreeHeight
Trees["Tree.height.m"]=TreeHeight(Trees[columns[2]], Trees[columns[1]])

# Outputs the new dataframe to a csv with the using input file's name
Trees.to_csv('../Output/%s_treeheights.csv' % (Output), index=False)**********************************************************************

Testing get_TreeHeight.py...

get_TreeHeight.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Please enter an input file

======================================================================
Inspecting script file Mapping.R...

File contents are:
**********************************************************************
## Loads a set of location data for various species, and plots these coordinates
## on a world map

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

## Packages ##

require(maps)

## Load Data ##

load("../Data/GPDDFiltered.RData")

################

# generates a world map and sets colours and margins
map("world", fill=TRUE, col="lightgreen", bg="lightblue", mar=c(0,0,0,0))
# plots points from data frame on map, sets colours and shape
points(gpdd[,3], gpdd[,2], col="black", pch=16)

## Biases ##

# The observations are largely along the same lattitude (30-60)

# The observations also occur only over Eurasia and North America (other than
# one point in Africa and two in Japan). This restricts them spatially.

# The observations are largely terrestrially biased.

**********************************************************************

Testing Mapping.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Loading required package: maps

======================================================================
Inspecting script file Vectorize.sh...

File contents are:
**********************************************************************
#!/bin/bash
#Author: Rachel Bates RLB18@Imperial.ac.uk
#Script: Vectorize.sh
#Desc: Compares R and Python run times for two scripts
#Arguments: none
#Date: 24.10.18

# Calculates running time for the R scripts
echo "Vectorize1.R execution time:"
time (Rscript Vectorize1.R &>-)
echo  "Vectorize2.R execution time:"
time (Rscript Vectorize2.R &>-)

# Calculates running time for the python scripts
echo "Vectorize1.py execution time:"
time (ipython3 Vectorize1.py &>-)
echo  "Vectorize2.py execution time:"
time (ipython3 Vectorize2.py &>-)
**********************************************************************

Testing Vectorize.sh...

Output (only first 500 characters): 

**********************************************************************
Vectorize1.R execution time:
Vectorize2.R execution time:
Vectorize1.py execution time:
Vectorize2.py execution time:

**********************************************************************

Encountered error:

real	0m0.224s
user	0m0.196s
sys	0m0.016s

real	0m0.352s
user	0m0.336s
sys	0m0.008s

real	0m0.742s
user	0m0.772s
sys	0m0.204s

real	0m1.264s
user	0m1.276s
sys	0m0.236s

======================================================================
Inspecting script file boilerplate.R...

File contents are:
**********************************************************************
## A boilerplate R script

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

## Packages ##

#require()

## Load Data ##



###############


MyFunction <- function(Arg1, Arg2){

    # Statements involving Arg1, Arg2:
    print (paste ("Argument", as.character(Arg1), "is a", class(Arg1)))
    print (paste ("Argument", as.character(Arg2), "is a", class(Arg2)))

    return (c(Arg1, Arg2)) # this is optional, but useful
}

MyFunction(1,2) #test the function
MyFunction("Riki", "Tiki") # Another test**********************************************************************

Testing boilerplate.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Argument 1 is a numeric"
[1] "Argument 2 is a numeric"
[1] 1 2
[1] "Argument Riki is a character"
[1] "Argument Tiki is a character"
[1] "Riki" "Tiki"

**********************************************************************

Code ran without errors

Time consumed = 0.08919s

======================================================================
Inspecting script file TreeHeight.R...

File contents are:
**********************************************************************
## This function calculates heights of trees given distance of each tree 
## from its base and angle to its top, using  the trigonometric formula 

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

## Load Data ##

Trees <- read.csv("../Data/trees.csv")

###############

TreeHeight <- function(degrees, distance){
    for (species in Trees){
        radians <- degrees * pi / 180
        height <- distance * tan(radians)
        print(paste("Tree height is:", height))

        return (height) #Outputs the calculated height

    }
}

#Creates a new column in Trees of the returned values from TreeHeight
Trees$Tree.height.m<-TreeHeight(Trees$Angle.degrees, Trees$Distance.m)

# Writes the dataframe to an output file
write.csv (Trees, "../Output/TreeHts.csv")


**********************************************************************

Testing TreeHeight.R...

Output (only first 500 characters): 

**********************************************************************
  [1] "Tree height is: 27.8021161438536" "Tree height is: 45.2460250644405"
  [3] "Tree height is: 14.6654828109493" "Tree height is: 14.9341751666304"
  [5] "Tree height is: 35.9703591412599" "Tree height is: 32.4102133664874"
  [7] "Tree height is: 17.4582436344144" "Tree height is: 30.1373803987097"
  [9] "Tree height is: 20.3124778877177" "Tree height is: 24.4316633466933"
 [11] "Tree height is: 27.5021323376702" "Tree height is: 25.1559006982628"
 [13] "Tree height is: 29.3924796426504" "Tre
**********************************************************************

Code ran without errors

Time consumed = 0.10096s

======================================================================
Inspecting script file PP_Lattice.R...

File contents are:
**********************************************************************
## Generates density plots and key descriptive stats for predator/prey masses
## Per type of feeding interaction. Outputs the results as a pdf for the graphs
## and a csv file of descriptive stats

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

## Packages ##

require(lattice)
require(tidyr)
library(plyr)
library(dplyr)

###############

MyDF <- read.csv("../Data/EcolArchives-E089-51-D1.csv")
dim(MyDF) #check the size of the data frame you loaded

MyDF$SizeRatio = with(MyDF, Predator.mass/Prey.mass) # Makes a new column with predator/prey mass ratios

pdf("../Output/Pred_Lattice.pdf", # Open blank pdf page using a relative path
    11.7, 8.3) # These numbers are page dimensions in inches
print (densityplot(~log(Predator.mass) | Type.of.feeding.interaction, data=MyDF))    
graphics.off(); #you can also use dev.off()

pdf("../Output/Prey_Lattice.pdf", # Open blank pdf page using a relative path
    11.7, 8.3) # These numbers are page dimensions in inches
print (densityplot(~log(Prey.mass) | Type.of.feeding.interaction, data=MyDF))    
graphics.off(); 

pdf("../Output/SizeRatio_Lattice.pdf", # Open blank pdf page using a relative path
    11.7, 8.3) # These numbers are page dimensions in inches
print (densityplot(~log(SizeRatio) | Type.of.feeding.interaction, data=MyDF))    
graphics.off();

# Creates a dataframe of the predator mass means and medians by feeding interaction
PredDF<-ddply(MyDF, "Type.of.feeding.interaction", function(MyDF){
    Mean = mean(log(MyDF$Predator.mass)) 
    Median = median(log(MyDF$Predator.mass))
    data.frame(Mean, Median)
})
# Adds a column detailing that these are all predator masses
PredDF$"Log(Type)"<-"Predator.mass"

# Creates a dataframe of the prey mass means and medians by feeding interaction
PreyDF<-ddply(MyDF, "Type.of.feeding.interaction", function(MyDF){
    Mean = mean(log(MyDF$Prey.mass)) 
    Median = median(log(MyDF$Prey.mass))
    data.frame(Mean, Median)
})
# Adds a column detailing that these are all prey masses
PreyDF$"Log(Type)"<-"Prey.mass"

# Creates a dataframe of the size ratio means and medians by feeding interaction
RatioDF<-ddply(MyDF, "Type.of.feeding.interaction", function(MyDF){
    Mean = mean(log(MyDF$SizeRatio)) 
    Median = median(log(MyDF$SizeRatio)) 
    data.frame(Mean, Median)
})
# Adds a column detailing that these are all size ratios
RatioDF$"Log(Type)"<-"Size.Ratio"

# Bind all three dataframes together
OutputDF<-rbind(PredDF, PreyDF, RatioDF)
# Place type of mass as the first column
OutputDF<-select(OutputDF, "Log(Type)", everything())


# Export the dataframe as a csv to the output folder
write.csv(OutputDF, ("../Output/PP_Results.csv"), row.names=F)
**********************************************************************

Testing PP_Lattice.R...

Output (only first 500 characters): 

**********************************************************************
[1] 34931    15

**********************************************************************

Encountered error:
Loading required package: lattice
Loading required package: tidyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:plyr’:

    arrange, count, desc, failwith, id, mutate, rename, summarise,
    summarize

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union


======================================================================
Inspecting script file next.R...

File contents are:
**********************************************************************
## Simple code to demonstrate the use of next in loops

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

###############

for (i in 1:10) {
  if ((i %% 2) == 0) 
    next # pass to next iteration of loop 
  print(i) # Only print if not exactly divisible by 2 (odd numbers)
}**********************************************************************

Testing next.R...

Output (only first 500 characters): 

**********************************************************************
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********************************************************************

Code ran without errors

Time consumed = 0.08748s

======================================================================
Inspecting script file Girko.R...

File contents are:
**********************************************************************
## Generates a girko plot of random data using ggplots

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

###############

build_ellipse <- function(hradius, vradius){ # function that returns an ellipse
  npoints = 250
  a <- seq(0, 2 * pi, length = npoints + 1)
  x <- hradius * cos(a)
  y <- vradius * sin(a)  
  return(data.frame(x = x, y = y))
}

N <- 250 # Assign size of the matrix
M <- matrix(rnorm(N * N), N, N) # Build the matrix
eigvals <- eigen(M)$values # Find the eigenvalues
eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe
my_radius <- sqrt(N) # The radius of the circle is sqrt(N)
ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse
names(ellDF) <- c("Real", "Imaginary") # rename the columns

# plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
  geom_point(shape = I(3)) +
  theme(legend.position = "none")

# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))

# finally, add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))
p

## CHECK IT WORKS
## SAVE OUTPUT TO PDF

pdf("../Output/Girko.pdf", # Open blank pdf page using a relative path
    12, 8)
# Prints the created ggplot to the pdf
print(p)
graphics.off()**********************************************************************

Testing Girko.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Error in ggplot(eigDF, aes(x = Real, y = Imaginary)) : 
  could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file Vectorize1.R...

File contents are:
**********************************************************************
## Shows the speed differences between using loops in R 
## and pre-defined functions that call from C

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

###############
#Creates a matrix of 1000000 random numbers
M <- matrix(runif(1000000),1000,1000)

#Sums all numbers in the matrix using nested loops
SumAllElements <- function(M){
  Dimensions <- dim(M)
  Tot <- 0
  for (i in 1:Dimensions[1]){
    for (j in 1:Dimensions[2]){
      Tot <- Tot + M[i,j]
    }
  }
  return (Tot)
}

#Time of nested loop solution
print("Time for loop solution to run:")
print(system.time(SumAllElements(M)))
#Time for vectorised solution
print("Time for vectorised solution to run:")
print(system.time(sum(M)))**********************************************************************

Testing Vectorize1.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Time for loop solution to run:"
   user  system elapsed 
  0.080   0.000   0.079 
[1] "Time for vectorised solution to run:"
   user  system elapsed 
  0.004   0.000   0.001 

**********************************************************************

Code ran without errors

Time consumed = 0.22506s

======================================================================
Inspecting script file break.R...

File contents are:
**********************************************************************
## Simple code to demonstrate the use of break within while loops

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

###############

i <- 0 #Initialize i
    while(i < Inf) { # Less than infinity
        if (i == 20) {
            break } # Break out of the while loop! 
        else { 
            cat("i equals " , i , " \n")
            i <- i + 1 # Update i
    }
}**********************************************************************

Testing break.R...

Output (only first 500 characters): 

**********************************************************************
i equals  0  
i equals  1  
i equals  2  
i equals  3  
i equals  4  
i equals  5  
i equals  6  
i equals  7  
i equals  8  
i equals  9  
i equals  10  
i equals  11  
i equals  12  
i equals  13  
i equals  14  
i equals  15  
i equals  16  
i equals  17  
i equals  18  
i equals  19  

**********************************************************************

Code ran without errors

Time consumed = 0.09256s

======================================================================
Inspecting script file plotLin.R...

File contents are:
**********************************************************************
## Plots a scatterplot of random numbers and adds a regression line using ggplots

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

## Packages ##

require(ggplot2)

###############

x <- seq(0, 100, by = 0.1)
y <- -4. + 0.25 * x +
  rnorm(length(x), mean = 0., sd = 2.5)

# and put them in a dataframe
my_data <- data.frame(x = x, y = y)

# perform a linear regression
my_lm <- summary(lm(y ~ x, data = my_data))

# plot the data
p <-  ggplot(my_data, aes(x = x, y = y,
                          colour = abs(my_lm$residual))
             ) +
  geom_point() +
  scale_colour_gradient(low = "black", high = "red") +
  theme(legend.position = "none") +
  scale_x_continuous(
    expression(alpha^2 * pi / beta * sqrt(Theta)))

# add the regression line
p <- p + geom_abline(
  intercept = my_lm$coefficients[1][1],
  slope = my_lm$coefficients[2][1],
  colour = "red")
# throw some math on the plot
p <- p + geom_text(aes(x = 60, y = 0,
                       label = "sqrt(alpha) * 2* pi"), 
                       parse = TRUE, size = 6, 
                       colour = "blue")


pdf("../Output/MyLinReg.pdf", # Open blank pdf page using a relative path
    9, 10)
# Prints the created ggplot to the pdf
print(p)
graphics.off()
**********************************************************************

Testing plotLin.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Loading required package: ggplot2

======================================================================
Inspecting script file basic_io.R...

File contents are:
**********************************************************************
## A simple script to illustrate R input-output.

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

## Load Data ##

MyData <- read.csv("../Data/trees.csv", header = TRUE) # import with headers

###############

write.csv(MyData, "../Output/MyData.csv") #write it out as a new file

write.table(MyData[1,], file = "../Output/MyData.csv",append=TRUE) # Append to it

write.csv(MyData, "../Output/MyData.csv", row.names=TRUE) # write row names

write.table(MyData, "../Output/MyData.csv", col.names=FALSE) # ignore column names**********************************************************************

Testing basic_io.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Warning message:
In write.table(MyData[1, ], file = "../Output/MyData.csv", append = TRUE) :
  appending column names to file

======================================================================
Inspecting script file Vectorize1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Shows the speed differences between using loops in python
    and vectorised solutions """

__author__ = 'Rachel Bates r.bates18@imperial.ac.uk'
__version__ = '0.0.1'


## IMPORTS ##

import numpy as np
import time

## CONSTANTS ##

#Create an 1000x1000 array of random numbers
M=np.random.uniform(size=(1000,1000))

## FUNCTIONS ##

def SumAllElements(M): #Sums all numbers in the matrix using nested loops
    Dimensions = M.shape
    Tot = 0
    for i in range(0, Dimensions[0]):
        for j in range(0, Dimensions[1]):
            Tot = Tot + M[i,j]
    return Tot

################

#Time of nested loop solution
start1=time.time()
SumAllElements(M)
end1=time.time()
print("Time for loop solution to run:")
print(end1-start1,"\n")

#Time for vectorised solution
start2=time.time()
M.sum(axis=(0,1))
end2=time.time()
print("Time for vectorised solution to run:")
print(end2-start2, "\n")
**********************************************************************

Testing Vectorize1.py...

Vectorize1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Time for loop solution to run:
0.20463895797729492 

Time for vectorised solution to run:
0.0006475448608398438 


**********************************************************************

Code ran without errors

Time consumed = 0.35345s

======================================================================
Inspecting script file try.R...

File contents are:
**********************************************************************
## Demonstrates usage of the try function

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

###############

x <- rnorm(50) #Generate your population
doit <- function(x){
	x <- sample(x, replace = TRUE)
	if(length(unique(x)) > 30) {#only take mean if sample was sufficient
		 print(paste("Mean of this sample was:", as.character(mean(x))))
		} 
	else {
		stop("Couldn't calculate mean: too few unique points!")
		}
	}

print("Using vectorisation:")
result <- lapply(1:100, function(i) try(doit(x), FALSE)) # try stops stop() from exiting the whole programme

print("Using loops:")
result <- vector("list", 100) #Preallocate/Initialize
for(i in 1:100) {
	result[[i]] <- try(doit(x), FALSE) # try stops stop() from exiting the whole programme
	}
**********************************************************************

Testing try.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Using vectorisation:"
[1] "Mean of this sample was: 0.203359512681976"
[1] "Mean of this sample was: 0.252324604329413"
[1] "Mean of this sample was: 0.332643271001967"
[1] "Mean of this sample was: 0.359974848474836"
[1] "Mean of this sample was: -0.155130421863554"
[1] "Mean of this sample was: 0.0445899973249828"
[1] "Mean of this sample was: 0.0301778658156861"
[1] "Mean of this sample was: 0.219682267556957"
[1] "Mean of this sample was: 0.00866766026334374"
[1] "Mean of this sample was
**********************************************************************

Encountered error:
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!

======================================================================
Inspecting script file apply2.R...

File contents are:
**********************************************************************
## Script to show more examples of apply usage

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

###############

SomeOperation <- function(v){
    # If the sum of the column is positive
    if (sum(v) > 0){
        # Multiply all values in the column by 100
        return (v * 100)
    }
    return (v)
}

M <- matrix(rnorm(100), 10, 10) # Creates a 10x10 matrix of random numbers
print (apply(M, 1, SomeOperation)) # Uses SomeOperation column-wise on the data within M
print (M)
**********************************************************************

Testing apply2.R...

Output (only first 500 characters): 

**********************************************************************
             [,1]        [,2]        [,3]        [,4]       [,5]        [,6]
 [1,]  0.33593110 -103.930789  0.66475004   26.625793  0.9296250  1.40139421
 [2,] -1.99276803  -58.713611 -0.56115983   18.483823  0.6960157 -0.46878642
 [3,]  0.82635033 -171.261039  0.46203373  158.039900  1.2478700  0.24954870
 [4,] -0.92332925 -182.135029 -0.63278550  164.265110 -1.4413796 -1.26319851
 [5,] -0.94912399   91.755094  1.00931221   -6.513596 -0.3707973 -1.53257031
 [6,]  1.34369298  134.878536 -0.832167
**********************************************************************

Code ran without errors

Time consumed = 0.09411s

======================================================================
Inspecting script file get_TreeHeight.R...

File contents are:
**********************************************************************
## This function calculates heights of trees given distance of each tree 
## from its base and angle to its top, using  the trigonometric formula
## It takes an input file from the user and outputs the result with an appropriate name 

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

## Load Data ##

# None

###############

args = commandArgs(trailingOnly=TRUE) # Only reads arguments after the script is called

if (length(args) == 0){ # If there is no arguments after the script name
    stop("No input file detected") # Exits the script, giving an error message
}

# Imports a dataframe from user input
Trees <- read.csv(args[1])

Output <- args[1] # Uses the user inputted file
Output <- gsub(".csv", "", Output) # removes .csv extension
Output <- gsub(".*/", "", Output) # removes everything before last /


TreeHeight <- function(degrees, distance){
    # Uses the trigonomic formula to calculate height
    for (species in Trees){
        radians <- degrees * pi / 180
        height <- distance * tan(radians)
        print(paste("Tree height is:", height))

        return (height) #Outputs the calculated height

    }
}

#Creates a new column in Trees of the returned values from TreeHeight
Trees$Tree.height.m<-TreeHeight(Trees$Angle.degrees, Trees$Distance.m)

# Writes the dataframe to an output file
write.csv (Trees, (sprintf('../Output/%s_treeheights.csv', Output)))


**********************************************************************

Testing get_TreeHeight.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Error: No input file detected
Execution halted

======================================================================
Inspecting script file TAutoCorr.R...

File contents are:
**********************************************************************
## Looks at the correlation between temperatures in FLorida in subsequent years
## Compares these correlations to those between non-sequential years to determine
## how independant they are. 

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

## Packages ##

require(ggplot2)

## Load Data ##

load("../Data/KeyWestAnnualMeanTemperature.RData")

################

summary(ats) # Gives the main descriptive stats for the data
#plot(ats) # Plots a scatter plot for the yearly temps

#cor(ats$Year, ats$Temp, method = c("spearman")) # Produces the spearman's rank correlation coefficient


v <- ats$Temp
v1 <- ats$Temp[2:100]; v1 <- c(v1, ats$Temp[1])
real<-(cor(v, v1))


## Attempt to create random sampling via loops. Non-functional
# Random_temps <- function(){
#     corr<-c()
#     for (i in 1:10000){
#         browser()
#         atsi<-ats[sample(nrow(ats)),]
#         r <- atsi$Temp
#         r1 <- atsi$Temp[2:100]; r1 <- c(r1, atsi$Temp[1])
#         corr[i]<-cor(r,r1)
#         print(corr)
#     }
# return(corr) 
# }

# Creates a list of the correlation coefficients for 10000 randomly re-arranged temperatures
Simulated_corrs<-replicate(10000, 
    {
        atsi<-ats[sample(nrow(ats)),]
        r <- atsi$Temp
        r1 <- atsi$Temp[2:100]; r1 <- c(r1, atsi$Temp[1])
        cor(r,r1)
    })


print(sprintf("There are %s simulated values out of %s that are larger than the value obtained from the real data.", 
sum(Simulated_corrs > real), length(Simulated_corrs)))
print(sprintf("The approximate p-value is therefore: %g", sum(Simulated_corrs > real)/length(Simulated_corrs)))

## Uses base R to make a histogram with a line for the real value
# plot(Simulated_corrs)
# hist(Simulated_corrs, xlim=c(-0.5, 0.4), xaxt="n")
# axis(side=1, at=c(-0.6, -0.4, -0.2, 0, 0.2, 0.4))
# abline(v=real)

## Uses ggplots to create a histogram with a line for the real value
p<-qplot(Simulated_corrs, geom="histogram", ylab="Frequency", xlab="Simulated Correlation Coefficients")+
theme_bw()+
geom_vline(xintercept= real)+
geom_text(aes(x=real-0.02, y=600, label="Real correlation coefficient", angle=90))+
theme(plot.margin=unit(c(2,2,2,2), "cm"))

pdf("../Output/TAutoCorr.pdf", # Open blank pdf page using a relative path
    9, 11.7)
# Prints the created ggplot to the pdf
print(p)
graphics.off()**********************************************************************

Testing TAutoCorr.R...

Output (only first 500 characters): 

**********************************************************************
      Year           Temp      
 Min.   :1901   Min.   :23.75  
 1st Qu.:1926   1st Qu.:24.99  
 Median :1950   Median :25.29  
 Mean   :1950   Mean   :25.31  
 3rd Qu.:1975   3rd Qu.:25.62  
 Max.   :2000   Max.   :26.35  
[1] "There are 5 simulated values out of 10000 that are larger than the value obtained from the real data."
[1] "The approximate p-value is therefore: 0.0005"

**********************************************************************

Encountered error:
Loading required package: ggplot2
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.

======================================================================
Inspecting script file Vectorize2.R...

File contents are:
**********************************************************************
## Runs the stochastic (with gaussian fluctuations) Ricker Eqn. using nested loops
## and without, showing the speed difference.

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

###############


stochrick<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100) { # Generates 1000 random values between 0.5 and 1.5 for p0 
  #initialize
  N<-matrix(NA,numyears,length(p0)) # Makes a matrix populated with NAs. It has rows = numyears and colums = length(p0)
  N[1,]<-p0 # Places the values of p0 into row 1

  for (pop in 1:length(p0)) #loop through the populations
  {
    for (yr in 2:numyears) #for each pop, loop through the years
    {
      #Adds the population size for each year, for each population
      N[yr,pop]<-N[yr-1,pop]*exp(r*(1-N[yr-1,pop]/K)+rnorm(1,0,sigma))
    }
  }
  return(N)
}



stochrickvect <- function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100) { # Generates 1000 random values between 0.5 and 1.5 for p0 
  #initialize
  N<-matrix(NA,numyears,length(p0)) # Makes a matrix populated with NAs. It has rows = numyears and colums = length(p0)
  N[1,]<-p0 # Places the values of p0 into row 1
  for (yr in 2:numyears) #for each pop, loop through the years
    {
      # Calculates the population size for each year across all columns
      N[yr,]<-N[yr-1,]*exp(r*(1-N[yr-1,]/K)+rnorm(1,0,sigma))
    }
  return(N)
}

# Displays computation time for nested loops
print ("Non-vectorised Stochastic Ricker takes:")
print(system.time(stochrick()))

# Displays computation time for non-nested loops
print ("Vectorised Stochastic Ricker takes:")
print(system.time(stochrickvect()))**********************************************************************

Testing Vectorize2.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Non-vectorised Stochastic Ricker takes:"
   user  system elapsed 
  0.248   0.004   0.253 
[1] "Vectorised Stochastic Ricker takes:"
   user  system elapsed 
  0.012   0.000   0.011 

**********************************************************************

Code ran without errors

Time consumed = 0.35766s

======================================================================
Inspecting script file DataWrangTidy.R...

File contents are:
**********************************************************************
## Wrangles a badly formatted dataset into a long format with correct datatypes 
## Using Tidyr and Dplyr

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

## Packages ##

require(tidyr)
require(dplyr)

## Load Data ##

# header = false because the raw data don't have real headers
MyData <- as_tibble(read.csv("../Data/PoundHillData.csv",header = F), stringsAsFactors = F) 

# header = true because we do have metadata headers
MyMetaData <- read.csv("../Data/PoundHillMetaData.csv",header = T, sep=";", stringsAsFactors = F)

##############


## Inspect the data ##

head(MyData)
fix(MyData)

# Gather all variables into 3 columns
new<-gather(MyData, Unique_ID, value, -V1)
# Spread out the data to true long format with separate species data
MyData<-spread(new, V1, value)

#tail(transposed)

# Rearrange the columns so that the treatment data comes first
MyData<-select(MyData, Cultivation, Block, Plot, Quadrat, everything())
# Removes unique ID column (only needed to rearrange the data)
MyData<-within(MyData, rm(Unique_ID))

####### Not dplyr or tidyr
# Replaces missing values with 0s
MyData[MyData == ""] = 0

#### Efforts to use dplyr 
#transposed %>% replace_na(list(0))

#df <- tibble(x = c(1, 2, NA), y = c("a", NA, "b"), z = list(1:5, NULL, 10:20))
#df %>% replace_na(list(x = 0, y = "unknown"))

# Does something but IDK
#transposed %>% mutate('Achillea millefolium' = replace("Achillea millefolium", "Achillea millefolium" == "" , "0"))
#mutate_all(transposed, funs(replace(., 0)))

# Example usage
#dat <- as_data_frame(c("Candy","Sanitizer","Candy","Water","Cake","Candy","Ice Cream","Gum","Candy","Coffee"))
#colnames(dat) <- "var"
#dat %>% mutate(var = replace(var, var != "Candy", "Not Candy"))

#numTable %>% mutate_all(funs(replace(., abs(. - mean(., na.rm = TRUE)) > 3 * sd(., na.rm = TRUE), NA)))

##Don't need to change to df as is already one

# Final formatting with one species column and counts for different treatments
MyWrangledData<-gather(MyData, Species, Count, 5:ncol(MyData))

# Block ensuring that all columns are the correct data type
MyWrangledData<-mutate(MyWrangledData, Cultivation=as.factor(Cultivation))
MyWrangledData<-mutate(MyWrangledData, Block=as.factor(Block))
MyWrangledData<-mutate(MyWrangledData, Plot=as.factor(Plot))
MyWrangledData<-mutate(MyWrangledData, Quadrat=as.factor(Quadrat))
MyWrangledData<-mutate(MyWrangledData, Species=as.factor(Species))
MyWrangledData<-mutate(MyWrangledData, Count=as.integer(Count))

str(MyWrangledData)**********************************************************************

Testing DataWrangTidy.R...

Output (only first 500 characters): 

**********************************************************************
# A tibble: 6 x 60
  V1    V2    V3    V4    V5    V6    V7    V8    V9    V10   V11   V12   V13  
  <fct> <fct> <fct> <fct> <fct> <fct> <fct> <fct> <fct> <fct> <fct> <fct> <fct>
1 Cult… octo… octo… octo… octo… octo… may   may   may   may   may   march march
2 Block a     a     a     a     a     a     a     a     a     a     a     a    
3 Plot  1     1     1     1     1     2     2     2     2     2     3     3    
4 Quad… Q1    Q2    Q3    Q4    Q5    Q1    Q2    Q3    Q4    Q5    Q1    Q2   
5 
**********************************************************************

Encountered error:
Loading required package: tidyr
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union


======================================================================
Inspecting script file preallocate.R...

File contents are:
**********************************************************************
## Script demonstarting the speed benefits of pre-allocating variables

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

###############

a <- 1 # Creates a vector of one value
no_allocate <- function(a){
    for (i in 1:1000000){ # Extends the vector as the function runs
        a[i] = 10
    }
}

print(system.time(no_allocate(a))) # Displays the computation time for no pre-allocation

a <- rep(NA, 1000000) # Creates a vector of 1000000 NA values
pre_allocate <- function(a){
    for (i in 1:1000000){
        a[i] = 10 # Allocates a value to each position on the vector
    }
}

print(system.time(pre_allocate(a))) # Displays the computation time when pre-allocating**********************************************************************

Testing preallocate.R...

Output (only first 500 characters): 

**********************************************************************
   user  system elapsed 
  0.372   0.016   0.389 
   user  system elapsed 
  0.044   0.000   0.045 

**********************************************************************

Code ran without errors

Time consumed = 0.60159s

======================================================================
Inspecting script file DataWrang.R...

File contents are:
**********************************************************************
## Using base R functions to wrangle a dataset from wide to long format

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

## Packages ##

require(reshape2)

## Load Data ##

# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../Data/PoundHillData.csv",header = F)) 

# header = true because we do have metadata headers
MyMetaData <- read.csv("../Data/PoundHillMetaData.csv",header = T, sep=";", stringsAsFactors = F)

###############


################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData)
fix(MyData) #Opens it in a new window
fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnaheadmes(TempData) <- MyData[1,] # assign column names from original data

############# Convert from wide to long format  ###############

# Uses reshape2 package

?melt #check out the melt function

# Places the edited dataframe into a properly formatted one
MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")

# Block that sets the data types for each column
MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])

# Block of instructions showing the structure of the new data frame
str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

**********************************************************************

Testing DataWrang.R...

Output (only first 500 characters): 

**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Encountered error:
Loading required package: reshape2

======================================================================
Inspecting script file TAutoCorr.tex...

File contents are:
**********************************************************************
\documentclass[12pt]{article}
\title{Temperature Changes in Florida over Sucessive years}
\author{Rachel Bates}
\date{24.10.18}
\usepackage{graphicx}

\begin{document}
  \maketitle

  \begin{abstract}
  This paper looks at how to calculate a p-value for temperature changes between sucessive years, using data from Florida as an example.  
  \end{abstract}

  \section{Methods}
  The temperatures from the sample set were randomly jumbled using R's sample function. A correlation coefficient was then determined for sucessive values on this list. This was done 10000 times to produce a distribution of values independant of the effect of year.

  \section{Results}
  The correlation coefficient for the correctly ordered data was 0.306 (3 s.f.)
  The sampled correlation coefficients ranged from -0.370 to 0.416, with a median of -0.010. Only 5 values were larger than the real data, giving an approximate p-value for the real data of $< 0.001$. 
  See Figure 1. for a graphical representation of the real value in relation to distribution of sampled values.

  \includegraphics[width=0.98\textwidth]{../Output/TAutoCorr}

  Figure 1. Distribution of n=10000 sampled correlation coefficients using temperature data from sucessive years in Florida. The correlation coefficient from the non-scrambled data is included as a line.

\end{document}**********************************************************************

Testing TAutoCorr.tex...

======================================================================
Inspecting script file MyBars.R...

File contents are:
**********************************************************************
## Creates a bar plot using ggplots

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

## Packages ##

require(ggplot2)

## Load Data ##

a <- read.table("../Data/Results.txt", header = TRUE)

###############

a$ymin <- rep(0, dim(a)[1]) # append a column of zeros

# Print the first linerange
p <- ggplot(a)
p <- p + geom_linerange(data = a, aes(
                          x = x,
                          ymin = ymin,
                          ymax = y1,
                          size = (0.5)
                          ),
                        colour = "#E69F00",
                        alpha = 1/2, show.legend = FALSE)

# Print the second linerange
p <- p + geom_linerange(data = a, aes(
                          x = x,
                          ymin = ymin,
                          ymax = y2,
                          size = (0.5)
                          ),
                        colour = "#56B4E9",
                        alpha = 1/2, show.legend = FALSE)

# Print the third linerange:
p <- p + geom_linerange(data = a, aes(
                          x = x,
                          ymin = ymin,
                          ymax = y3,
                          size = (0.5)
                          ),
                        colour = "#D55E00",
                        alpha = 1/2, show.legend = FALSE)

# Annotate the plot with labels:
p <- p + geom_text(data = a, aes(x = x, y = -500, label = Label))

# now set the axis labels, remove the legend, and prepare for bw printing
p <- p + scale_x_continuous("My x axis",
                            breaks = seq(3, 5, by = 0.05)) + 
                            scale_y_continuous("My y axis") + 
                            theme_bw() + 
                            theme(legend.position = "none") 

## SAVE OUTPUT TO PDF

pdf("../Output/MyBars.pdf", # Open blank pdf page using a relative path
    9, 11.7)
# Prints the created ggplot to the pdf
print(p)
graphics.off()**********************************************************************

Testing MyBars.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Loading required package: ggplot2
Warning message:
Removed 91 rows containing missing values (geom_text). 

======================================================================
Inspecting script file control.R...

File contents are:
**********************************************************************
## Some code exemlifying control flow constructs in R

# Author: Rachel Bates (r.bates18@imperial.ac.uk)
# Version: 0.0.1

## Clear the directory ##

rm(list=ls())

###############

##If statement 
a <- TRUE
if (a == TRUE){
    print ("a is TRUE")
    } else {
    print ("a is FALSE")
}

z <- runif(1) # generates a random number
if (z <= 0.5) {
    print ("Less than a half")
}

## For loop using a sequence
for (i in 1:100){ # Runs for values 1 through to 100
    j <- i * i
    print (paste (i, " squared is", j ))
}

## For loop over vector of strings
for (species in c('Heliodoxa rubinoides', # Implicit loop
                 'Boissonneaua jardini', 
                 'Sula nebouxii'))
{
    print (paste ('The species is', species))
}

## For loop using a vector
v1 <- c("a", "bc", "def")
for (i in v1){
    print(i)
}

## While loop
i <- 0
while (i<100){ # Runs only if the conditions are met
    i <- i+1
    print(i^2)
}
**********************************************************************

Testing control.R...

Output (only first 500 characters): 

**********************************************************************
[1] "a is TRUE"
[1] "Less than a half"
[1] "1  squared is 1"
[1] "2  squared is 4"
[1] "3  squared is 9"
[1] "4  squared is 16"
[1] "5  squared is 25"
[1] "6  squared is 36"
[1] "7  squared is 49"
[1] "8  squared is 64"
[1] "9  squared is 81"
[1] "10  squared is 100"
[1] "11  squared is 121"
[1] "12  squared is 144"
[1] "13  squared is 169"
[1] "14  squared is 196"
[1] "15  squared is 225"
[1] "16  squared is 256"
[1] "17  squared is 289"
[1] "18  squared is 324"
[1] "19  squared is 361"
[1] "20 
**********************************************************************

Code ran without errors

Time consumed = 0.09352s

======================================================================
======================================================================
Finished running scripts

Ran into 14 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 99.5

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!